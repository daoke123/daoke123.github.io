<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Daoke</title>
  
  <subtitle>记录笔记只是怕忘记</subtitle>
  <link href="http://daoke123.github.io/atom.xml" rel="self"/>
  
  <link href="http://daoke123.github.io/"/>
  <updated>2022-11-22T14:31:57.768Z</updated>
  <id>http://daoke123.github.io/</id>
  
  <author>
    <name>daoke</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VPS主机一键更换国内软件源脚本</title>
    <link href="http://daoke123.github.io/2022/11/22/VPShost/"/>
    <id>http://daoke123.github.io/2022/11/22/VPShost/</id>
    <published>2022-11-22T14:31:00.000Z</published>
    <updated>2022-11-22T14:31:57.768Z</updated>
    
    <content type="html"><![CDATA[<p><a class="link"   href="https://gitee.com/SuperManito/LinuxMirrors" >https://gitee.com/SuperManito/LinuxMirrors<i class="fas fa-external-link-alt"></i></a> <a class="link"   href="https://github.com/SuperManito/LinuxMirrors" >https://github.com/SuperManito/LinuxMirrors<i class="fas fa-external-link-alt"></i></a></p><p><code>bash &lt;(curl \-sSL https://gitee.com/SuperManito/LinuxMirrors/raw/main/ChangeMirrors.sh) </code></p><p>如果提示 Command <code>curl</code>not found 则说明当前未安装 curl 软件包</p><p><code>sudo yum install -y curl  sudo apt-get install -y curl</code></p><p>如果提示 Command <code>wget</code>not found 则说明当前未安装 wget 软件包</p><p><code>sudo yum install -y wget  sudo apt-get install -y wget</code></p><p>如果提示 bash: &#x2F;proc&#x2F;self&#x2F;fd&#x2F;11: No such file or directory，请切换至 Root 用户执行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;https://gitee.com/SuperManito/LinuxMirrors&quot; &gt;https://gitee.com/SuperManito/LinuxMirrors&lt;i class=&quot;fas fa-external-</summary>
      
    
    
    
    
    <category term="vps" scheme="http://daoke123.github.io/tags/vps/"/>
    
  </entry>
  
  <entry>
    <title>Rclone挂载Google Drive网盘</title>
    <link href="http://daoke123.github.io/2022/11/22/RcloneGoogle-Drive/"/>
    <id>http://daoke123.github.io/2022/11/22/RcloneGoogle-Drive/</id>
    <published>2022-11-22T14:22:00.000Z</published>
    <updated>2022-11-22T14:25:51.984Z</updated>
    
    <content type="html"><![CDATA[<p>挂载GD  到这里结束配置 rclone，下面要把 Google Drive 网盘挂载到云主机&#x2F;Vps 上和设置开机自启，自动挂载 Google Drive 网盘  首先安装fuse:</p><p><code>apt-get install fuse</code>  #debian</p><p><code>yum install fuse</code>   #centos</p><p>新建一个你要挂载的目录，例如我要挂载到</p><p><code>/home/gdrive</code></p><p><code>mkdir -p /home/gdrive</code></p><p>再执行挂载命令：</p><p><code>rclone mount gd: /home/gdrive --allow-other --allow-non-empty --vfs-cache-mode writes</code></p><p>gd 为Rclone的配置名称，比如你在创建配置 rclone 的时候 Name 填的 gd，&#x2F;home&#x2F;gdrive 为本地路径（注意空格别漏了）； 这里还可以自定义设置网盘里的文件夹路径，例如：</p><p><code>rclone mount gd:backup /home/gdrive --allow-other --allow-non-empty --vfs-cache-mode writes</code></p><p>卸载 Google Drive 磁盘</p><p><code>fusermount -qzu /home/gdrive</code></p><p>挂载只要几秒钟，但终端不会返回成功信息，关闭 SSH 重连即可。  重连后查看是否挂载成功： <code>df-h</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;挂载GD  到这里结束配置 rclone，下面要把 Google Drive 网盘挂载到云主机&amp;#x2F;Vps 上和设置开机自启，自动挂载 Google Drive 网盘  首先安装fuse:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;apt-get install fuse&lt;/code</summary>
      
    
    
    
    <category term="vps" scheme="http://daoke123.github.io/categories/vps/"/>
    
    
    <category term="rclone" scheme="http://daoke123.github.io/tags/rclone/"/>
    
  </entry>
  
  <entry>
    <title>Hexo的配置</title>
    <link href="http://daoke123.github.io/2022/11/22/Hexo/"/>
    <id>http://daoke123.github.io/2022/11/22/Hexo/</id>
    <published>2022-11-22T14:15:00.000Z</published>
    <updated>2022-11-22T14:57:24.148Z</updated>
    
    <content type="html"><![CDATA[<pre class="EnlighterJSRAW" data-enlighter-language="md">docker exec -it hexo /bin/bash git config --global user.email "xxxx@gmail.com"git config --global user.name "xxxx"生成 和 发布hexo clean && hexo d github生成 hexo g && hexo generate发布hexo d   && hexo deploy]]></content>
    
    
      
      
    <summary type="html">&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;md&quot;&gt;
docker exec -it hexo /bin/bash 

git config --global user.email &quot;xxxx@gmail.com&quot;
g</summary>
      
    
    
    
    <category term="hexo" scheme="http://daoke123.github.io/categories/hexo/"/>
    
    
    <category term="hexo" scheme="http://daoke123.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>甲骨文(ARM/x86均可) 使用netboot任意重装系统-silence</title>
    <link href="http://daoke123.github.io/2022/11/22/%E7%94%B2%E9%AA%A8%E6%96%87/"/>
    <id>http://daoke123.github.io/2022/11/22/%E7%94%B2%E9%AA%A8%E6%96%87/</id>
    <published>2022-11-22T14:00:00.000Z</published>
    <updated>2022-11-22T14:55:56.036Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="甲骨文-ARM-x2F-x86均可-oracle-cloud使用netboot任意重装系统"><a href="#甲骨文-ARM-x2F-x86均可-oracle-cloud使用netboot任意重装系统" class="headerlink" title="甲骨文(ARM&#x2F;x86均可) oracle cloud使用netboot任意重装系统"></a>甲骨文(ARM&#x2F;x86均可) oracle cloud使用netboot任意重装系统</h4></blockquote><h6 id="一-创建控制台连接-注意-创建vps时候记得开默认的系统-oracle-linux-其他系统的bios和它不一定相同-试过ubuntu是不一样的-其他没尝试过"><a href="#一-创建控制台连接-注意-创建vps时候记得开默认的系统-oracle-linux-其他系统的bios和它不一定相同-试过ubuntu是不一样的-其他没尝试过" class="headerlink" title="一.创建控制台连接 注意:创建vps时候记得开默认的系统,oracle linux,其他系统的bios和它不一定相同(试过ubuntu是不一样的,其他没尝试过)"></a>一.创建控制台连接 注意:创建vps时候记得开默认的系统,oracle linux,其他系统的bios和它不一定相同(试过ubuntu是不一样的,其他没尝试过)</h6><p>这里我选择用本地的wsl生成了ssh key命令如<br><code>ssh-keygen -t rsa   cat .ssh/id\_rsa.pub</code><br>即可获得你的ssh公钥   然后去创建控制台连接粘贴密钥   创建完成后,复制linux的串口连接命令   再将命令复制到刚才的linux系统里就可以连接了,连接时候会有警告,输入yes即可   </p><h5 id="二-下载netboot-efi-这是重装系统前的最后一步-去netboot-xyz下载EFI引导文件"><a href="#二-下载netboot-efi-这是重装系统前的最后一步-去netboot-xyz下载EFI引导文件" class="headerlink" title="二.下载netboot.efi 这是重装系统前的最后一步,去netboot.xyz下载EFI引导文件"></a>二.下载netboot.efi 这是重装系统前的最后一步,去netboot.xyz下载EFI引导文件</h5><h6 id="x86-64"><a href="#x86-64" class="headerlink" title="x86_64:"></a>x86_64:</h6><p><code>https://boot.netboot.xyz/ipxe/netboot.xyz.efi</code> </p><h6 id="arm64"><a href="#arm64" class="headerlink" title="arm64:"></a>arm64:</h6><p><code>https://boot.netboot.xyz/ipxe/netboot.xyz-arm64.efi</code>  <br>将efi文件wget到vps的<code>/boot/efi/EFI</code>文件夹下即可   </p><h5 id="三-开始重装-连接上串口连接后-去网站控制台重启vps-然后回到连接中-狂按ESC-即可进入bios"><a href="#三-开始重装-连接上串口连接后-去网站控制台重启vps-然后回到连接中-狂按ESC-即可进入bios" class="headerlink" title="三.开始重装 连接上串口连接后,去网站控制台重启vps,然后回到连接中,狂按ESC,即可进入bios"></a>三.开始重装 连接上串口连接后,去网站控制台重启vps,然后回到连接中,狂按ESC,即可进入bios</h5><p>这里选择第三项`Boot Maintenance Manager`按回车进入   选择<code>Boot From File</code>  <br>然后再按一次回车进入默认的硬盘,选择EFI文件夹下的<code>netboot.efi</code>进入<code>netboot</code>   这是启动netboot后的界面,选择<code>Linux Network Installs</code>开始安装  <br>可以看到能安装的系统相当多,我这里选择安装debian11   安装时候记得选择<code>Text Based Install</code> 这样再次重新启动后，系统正常情况下是自动启动进iPXE当中去而不是默认的Debian&#x2F;Ubuntu中去  <br>进了netboot.xyz的启动功能后，用   <code>chain –autofree http://boot.netboot.xyz</code> 再从列表中选择自己要的系统，比如CentOS或Debian ARM 用 netboot.xyz<br>装 CentOS 会下载不到内核，手动下载一下就行； x86_64 CentOS 不能装版本大于7.2的，因为内存不够。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;h4 id=&quot;甲骨文-ARM-x2F-x86均可-oracle-cloud使用netboot任意重装系统&quot;&gt;&lt;a href=&quot;#甲骨文-ARM-x2F-x86均可-oracle-cloud使用netboot任意重装系统&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="vps" scheme="http://daoke123.github.io/categories/vps/"/>
    
    
    <category term="甲骨文" scheme="http://daoke123.github.io/tags/%E7%94%B2%E9%AA%A8%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>使用 rclone 每天定时备份博客网站内容及mysql数据库到 Google Drive/Onedrive等网盘</title>
    <link href="http://daoke123.github.io/2022/11/22/rclone-Google-Drive-Onedriv/"/>
    <id>http://daoke123.github.io/2022/11/22/rclone-Google-Drive-Onedriv/</id>
    <published>2022-11-22T03:56:00.000Z</published>
    <updated>2022-11-22T14:48:18.796Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RCLONE-官方提供了一键安装脚本"><a href="#RCLONE-官方提供了一键安装脚本" class="headerlink" title="RCLONE 官方提供了一键安装脚本"></a>RCLONE 官方提供了一键安装脚本</h2><p><code>curl https://rclone.org/install.sh | sudo bash</code><br>rclone config</p><h2>备份脚本编写及授权</h2>创建脚本文件：<p><code>mkdir /home/Backup</code></p><p><code>chmod +x /home/Backup</code></p><p><code class="hljs">touch /home/Backup/backup.sh<br>vi /home/Backup/backup.sh</code></p><pre class="EnlighterJSRAW" data-enlighter-language="md">#!/bin/bash# 定义GOOGLE DRIVE的备份目录GD_PATH="GdriveBackup:Backup"# 定义备份的目录及文件，不同的目录用空格分开BACKUP_SRC="/home/wwwroot/omo.moe/usr"# 定义临时文件存放目录BACKUP_DST="/home/Backup"# 设置MYSQL基本信息 MYSQL_SERVER="localhost"MYSQL_USER="root"MYSQL_PASS="your password"# 定义想要备份的数据库，多个数据库用空格分开BACKUP_DATABASE="typecho_omo"# 定义文件前缀名NOW=$(date +"%Y.%m.%d")OLD=$(date -d -5day +"%Y.%m.%d")# 备份网站数据文件zip -r $BACKUP_DST/auto_fileData_$NOW.zip $BACKUP_SRC# 备份mysql数据库mysqldump -u $MYSQL_USER -h $MYSQL_SERVER -p$MYSQL_PASS --databases $BACKUP_DATABASE &gt; $BACKUP_DST/$NOW-auto-Databases.sql# 使用rclone上传到google driverclone copy -v --stats 15s --bwlimit 40M $BACKUP_DST/ --include "$NOW-auto-Databases.sql" --include "auto_fileData_$NOW.zip" $GD_PATH# 删除本地的临时文件rm -f $BACKUP_DST/$NOW-auto-Databases.sql $BACKUP_DST/auto_fileData_$NOW.zip# 删除5天前的备份rclone delete $GD_PATH/ --include "$OLD-auto-Databases.sql" --include "auto_fileData_$OLD.zip"</pre><p>使用chmod指令赋予执行权限：</p><p><code>chmod +x /home/Backup/backup.sh</code></p><p>三、创建自动备份任务并测试</p><p>使用 crontab 每天4点定时执行自动备份脚本：</p><p><code>crontab -e</code></p><p>复制以下内容粘贴并输入:wq保存：</p><p><code>0 4 * * * /bin/bash /home/backup/backup.sh &gt;/dev/null 2&gt;&amp;1</code></p><p>手动测试看看脚本是否正确运行：</p><p><code>bash /home/Backup/backup.sh</code></p><p>时区设置为东八区：</p><p><code>timedatectl set-timezone Asia/Shanghai</code></p><p>重启定时任务：</p><p><code>service crond restart</code></p><p>重启系统日志：</p><p><code>service rsyslog restart</code></p><p>最后观察下系统日志尾巴状态，是否时区已经调整成功：</p><p><code>tail -f /var/log/cron</code></p><p>转：<a class="link"   href="https://omo.moe/archives/616/" >https://omo.moe/archives/616/<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RCLONE-官方提供了一键安装脚本&quot;&gt;&lt;a href=&quot;#RCLONE-官方提供了一键安装脚本&quot; class=&quot;headerlink&quot; title=&quot;RCLONE 官方提供了一键安装脚本&quot;&gt;&lt;/a&gt;RCLONE 官方提供了一键安装脚本&lt;/h2&gt;&lt;p&gt;&lt;code&gt;</summary>
      
    
    
    
    <category term="vps" scheme="http://daoke123.github.io/categories/vps/"/>
    
    
    <category term="rclone" scheme="http://daoke123.github.io/tags/rclone/"/>
    
    <category term="备份" scheme="http://daoke123.github.io/tags/%E5%A4%87%E4%BB%BD/"/>
    
  </entry>
  
  <entry>
    <title>在LNMP环境下实现反向代理</title>
    <link href="http://daoke123.github.io/2022/11/10/%E5%9C%A8LNMP%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>http://daoke123.github.io/2022/11/10/%E5%9C%A8LNMP%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</id>
    <published>2022-11-10T14:25:00.000Z</published>
    <updated>2022-11-10T14:41:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>安装LNMP稳定版只需要安装nginx</p><pre class="EnlighterJSRAW" data-enlighter-language="md">wget http://soft.vpser.net/lnmp/lnmp1.9.tar.gz -cO lnmp1.9.tar.gz &amp;&amp; tar zxf lnmp1.9.tar.gz &amp;&amp; cd lnmp1.9 &amp;&amp; ./install.sh nginx</pre><p><strong>添加网站(虚拟主机)</strong></p><p><code>lnmp vhost add</code></p><p>编辑网站nginx配置文件</p><p><code>cd usr/local/nginx/conf/vhost</code></p><p><code>ls</code></p><p><code>xxx.com.conf</code></p><p>配置Nginx文件，将下列代码插入nginx文件中，注意端口、路径要保持一致</p><pre class="EnlighterJSRAW" data-enlighter-language="asm">location /app{proxy_redirect off;proxy_pass http://127.0.0.1:8443;proxy_http_version 1.1;proxy_set_header Upgrade $http_upgrade;proxy_set_header Connection "upgrade";proxy_set_header Host $http_host;}</pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;安装LNMP稳定版只需要安装nginx&lt;/p&gt;
&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;md&quot;&gt;wget http://soft.vpser.net/lnmp/lnmp1.9.tar.gz -cO lnmp1</summary>
      
    
    
    
    <category term="lnmp" scheme="http://daoke123.github.io/categories/lnmp/"/>
    
    
  </entry>
  
  <entry>
    <title>vps常用一键脚本与命令</title>
    <link href="http://daoke123.github.io/2022/11/10/vps%E5%B8%B8%E7%94%A8%E4%B8%80%E9%94%AE%E8%84%9A%E6%9C%AC%E4%B8%8E%E5%91%BD%E4%BB%A4/"/>
    <id>http://daoke123.github.io/2022/11/10/vps%E5%B8%B8%E7%94%A8%E4%B8%80%E9%94%AE%E8%84%9A%E6%9C%AC%E4%B8%8E%E5%91%BD%E4%BB%A4/</id>
    <published>2022-11-10T14:24:20.000Z</published>
    <updated>2022-11-10T14:55:10.000Z</updated>
    
    <content type="html"><![CDATA[<p style="text-align: left;">更新源</p><code>apt update &amp;&amp; apt upgrade -y</code><h4>安装常用软件</h4><code>apt install net-tools vim wget git screen curl xz-utils unzip sudo zip t -y</code><span id="more"></span><h4>ssh与宝塔出现乱码</h4><blockquote>ubuntu与debian适用</blockquote><code>sudo echo 'LC_ALL="en_US.UTF-8"' &gt;&gt; /etc/default/locale</code><h4>开启宝塔ipv6</h4><code>echo True &gt; /www/server/panel/data/ipv6.pl</code><p><code>bt restart</code></p><h4>服务器时间</h4><code>sudo dpkg-reconfigure tzdata</code><h4>免密登录，公钥换成自己的</h4><pre class="EnlighterJSRAW" data-enlighter-language="latex">mkdir /root/.ssh;echo "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIN+I1HhcBcgv/6WGPTmnsUuV3cun1mUOAmwBdJnk7JwL xingchen" &gt;&gt;/root/.ssh/authorized_keys</pre>&nbsp;<hr /><h4>caddy安装</h4><code>echo "deb [trusted=yes] https://apt.fury.io/caddy/ /" | sudo tee -a /etc/apt/sources.list.d/caddy-fury.list</code><p><code>apt install caddy</code></p><h4>开启ubuntu与debian bbr加速</h4><pre class="EnlighterJSRAW" data-enlighter-language="abap">echo "net.core.default_qdisc=fq" &gt;&gt; /etc/sysctl.conf echo "net.ipv4.tcp_congestion_control=bbr" &gt;&gt; /etc/sysctl.conf</pre><pre>测试IPv4优先还是IPv6优先<code>curl ip.p3terx.com</code></pre><pre>测试25端口是否开放telnet smtp.aol.com 25</pre><p>非大陆Docker安装</p><p><code>wget -qO- get.docker.com | bash</code></p><p>非大陆Docker-compose安装 </p><pre>sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose</pre>]]></content>
    
    
    <summary type="html">&lt;p style=&quot;text-align: left;&quot;&gt;更新源&lt;/p&gt;
&lt;code&gt;apt update &amp;amp;&amp;amp; apt upgrade -y&lt;/code&gt;
&lt;h4&gt;安装常用软件&lt;/h4&gt;
&lt;code&gt;apt install net-tools vim wget git screen curl xz-utils unzip sudo zip t -y&lt;/code&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>mjj版的linux入门教程</title>
    <link href="http://daoke123.github.io/2022/11/02/mjj/"/>
    <id>http://daoke123.github.io/2022/11/02/mjj/</id>
    <published>2022-11-01T22:24:00.000Z</published>
    <updated>2022-11-01T22:37:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文的首要目的是给予Linux初学者一个简单、易学的教程，以便在看完本文后对Linux系统有一个基础的认识（而非系统级的深入），可以对常见的软件和功能进行配置，甚至可以自己写一写一键脚本。</p><p>本教程写于2021年下半年，采用的系统为Debian GNU&#x2F;Linux 11 (bullseye)。</p><span id="more"></span><h2 id="0-前言吐槽CentOS"><a href="#0-前言吐槽CentOS" class="headerlink" title="0 前言吐槽CentOS"></a>0 前言吐槽CentOS</h2><p><strong>解释使用Debian而不是CentOS的原因</strong></p><p>国内首批接触Linux系统的人主要集中在科研院校，大多数是延续了Unix-like的背景，在千禧年前后才有了真正意义上的Linux使用者：纯Linux平台开发、运行服务和应用，他们或直接或间接地推广了Linux系统。红帽（Red Hat, Inc.）在1994年就开始发布了同名的操作系统：Red Hat Linux（后改组为Red Hat Enterprise Linux，缩写为RHEL）。得益于红帽优秀的团队和商业支持，RHEL这一发行版迅速占领了国内市场。彼时的国内计算机市场远不如今日繁荣，在口口相传和红帽的推广中，RHEL成为了Linux入门的主流选项，即使后来号称用户友好的Ubuntu出现了，绝大多数尝鲜的人依然能看到众多网站里面只提供RHEL版本的教程。</p><p>CentOS是根据RHEL的源码重新编译的，等于换商标版本的RHEL，软件层面上，两者无本质区别。但CentOS是反人类的，至少是反入门用户的。使用RHEL的基本为商业用户，可以付费获得红帽的技术支持，或者干脆有一个自己的维护团队；而CentOS作为一个社区自发形成的操作系统，拥有落后的软件源&#x2F;包，繁琐的配置，和对个人用户而言根本没有必要的SElinux等。举个例子，很多入门者修改SSH端口的时候，发现所有的操作都没有问题，但是死活无法生效，最终发现是没有在SElinux里面放行。如果你想安装个软件，你就得考虑是从落后主流版本好几代的软件源&#x2F;包里面安装，还是自己下载源码进行编译以获取主流的使用体验。对于入门者而言，CentOS的安全性和稳定性是个虚假的概念，毕竟让一个刚接触Linux的人去自己编译源码安装，无异于让小学生上战场，输了就说是小学生战斗力太弱。</p><p>所以本文以Debian GNU&#x2F;Linux（后续简称为Debian）来演示，也有着推广Debian的意思在里面，毕竟相比于Ubuntu往系统里面塞包括snap在内的一系列私货而言，Debain始终遵循着一个纯净的Linux的要求。而其他一些发行版，要么是专用性太强（如SUSE），要么是入门者不友好（如 Arch Linux），权衡之后，选择了写本文时，最新的Debian系统，即Debian GNU&#x2F;Linux 11 (bullseye)。</p><h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1 环境搭建"></a>1 环境搭建</h2><h3 id="1-1-系统选择与安装"><a href="#1-1-系统选择与安装" class="headerlink" title="1.1 系统选择与安装"></a>1.1 系统选择与安装</h3><p>Debian的安装包有一系列的前缀或者后缀，例如在默认的下载地址<code>https://www.debian.org/download</code>中的是<code>debian-11.0.0-amd64-netinst.iso</code>。其中，</p><ul><li>11代表大版本是11，代号是bullseye，各版本代号都来源于电影《玩具总动员》中的角色名称；</li><li>amd64是指系统为64位的，i386或者x86是32位的，amd64或者x86-64是64位的，32位系统已经被逐步弃用，目前仅在特定行业中使用；</li><li>netinst是网络安装版本，只是个安装器，安装过程需要联网，而DVD后缀的是完整版（如：debian-11.0.0-amd64-DVD-1.iso），如果系统太大，会在DVD后面加数字，默认DVD-1是完整版本，其后数字的是软件源&#x2F;包；</li><li>带firmware前缀的是包含第三方非开源驱动的（如：firmware-11.1.0-amd64-DVD-1.iso），其中就包含intel和Realtek等公司的闭源网卡驱动。</li></ul><p>VPS全称为virtual private server（虚拟专用服务器），如果需要安装纯净版的Debian 11系统，推荐使用vicer的Linux一键重装脚本（如下）：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash &lt;(wget --no-check-certificate -qO- &#x27;https://raw.githubusercontent.com/MoeClub/Note/master/InstallNET.sh&#x27;) -d 11 -v 64 -p &quot;自定义root密码&quot; -port &quot;自定义ssh端口&quot;</span><br></pre></td></tr></table></figure><h3 id="1-2-常用的命令"><a href="#1-2-常用的命令" class="headerlink" title="1.2 常用的命令"></a>1.2 常用的命令</h3><p><code>cat</code> 用于查看文本文件的内容，如<code>cat /etc/os-release</code> 将显示系统信息，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PRETTY_NAME=&quot;Debian GNU/Linux 11 (bullseye)&quot;</span><br><span class="line">NAME=&quot;Debian GNU/Linux&quot;</span><br><span class="line">VERSION_ID=&quot;11&quot;</span><br><span class="line">VERSION=&quot;11 (bullseye)&quot;</span><br><span class="line">VERSION_CODENAME=bullseye</span><br><span class="line">ID=debian</span><br><span class="line">HOME_URL=&quot;https://www.debian.org/&quot;</span><br><span class="line">SUPPORT_URL=&quot;https://www.debian.org/support&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;https://bugs.debian.org/&quot;</span><br></pre></td></tr></table></figure><p><code>touch</code> 新建文本文件，如<code>touch /home/hello.py</code> 将在<code>home</code> 文件夹下新建一个Python文件。</p><p><code>ls</code> 列出所有文件，但默认只是显示出最基础的文件和文件夹，如果需要更详细的信息，则使用<code>ls -la</code>，这将列出包括隐藏文件在内的所有文件和文件夹，并且给出对应的权限、大小和日期等信息。</p><p><code>cd</code> 进入指定文件夹，如<code>cd /home</code> 将进入<code>home</code>目录。返回上层目录的命令是<code>cd ..</code>，返回刚才操作的目录的命令是<code>cd -</code>。</p><p><code>mkdir</code> 新建文件夹，如<code>mkdir /home/Python</code> 将在<code>home</code> 文件夹下新建一个<code>Python</code> 文件夹。</p><p><code>mv</code> 移动文件和文件夹，也可以用来修改名称，如<code>mv /home/hello.py /home/helloworld.py</code> 将上文的<code>hello.py</code>重命名为<code>helloworld.py</code>，<code>mv /home/helloworld.py /home/Python/helloworld.py</code> 将<code>helloworld.py</code> 由<code>home</code>文件夹移动到了次级的<code>Python</code>文件夹。</p><p><code>cp</code> 复制文件，<code>cp /home/Python/hellowrold.py /home/Python/HelloWorld.py</code> 将<code>helloworld.py</code>复制为<code>HelloWolrd.py</code>。注意：Linux系统严格区分大小写，<code>helloworld.py</code>和<code>HelloWolrd.py</code>是两个文件。如果想复制整个文件夹，则需要带<code>r</code>，即<code>cp -r</code>，但此命令无法复制隐藏文件夹，需要使用<code>cp -r pathA/. pathB</code> 注意这个点<code>.</code>是灵魂。</p><p><code>rm</code> 删除，即江湖传说中<code>rm -rf</code> ，<code>r</code>为递归，可以删除文件夹中的文件，<code>f</code>为强制删除。<code>rm /home/Python/helloworld.py</code> 可以删除刚才的<code>helloworld.py</code> 文件，而想删除包括<code>Python</code> 在内的所有文件，则是<code>rm -rf /home/Python</code> 。</p><p><code>du -lh</code> 查看当前文件夹下，各文件、文件夹的大小，<code>l</code>是硬链接（软连接类似于快捷方式），<code>h</code>是让文件自动使用K&#x2F;M&#x2F;G显示而不是只有K。</p><h3 id="1-3-基础文本编辑器nano、vim"><a href="#1-3-基础文本编辑器nano、vim" class="headerlink" title="1.3 基础文本编辑器nano、vim"></a>1.3 基础文本编辑器nano、vim</h3><p>Linux系统的一大优势（同时也是劣势）是默认不需要GUI，因此节省了大量的性能开支，无GUI版本的Debian 11可以在512M甚至更小内存的VPS上正常启动和运行。但缺少GUI加大了入门者修改文件的难度，所幸Debian 11自带了简便易用的nano文本编辑器。以下以修改系统的更新源为例</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nano /etc/apt/sources.list #打开sources.list文件，在Linux系统中，#是注释符，其后的内容会被忽略</span><br></pre></td></tr></table></figure><p><img                       lazyload                     alt="image"                     data-src="https://raw.githubusercontent.com/uselibrary/Getting-Started-with-Linux/main/images/nano_ui.jpg"                      alt="nano_ui"                ></p><p>如图所示，即为<code>nano</code>打开<code>sources.list</code>后的界面，最下面两行为提示，比如<code>Ctrl+E</code>为退出，如果文档被改动了，则会出现下图，询问是否保存。如果没有被更改，则会直接退出。</p><p><img                       lazyload                     alt="image"                     data-src="https://raw.githubusercontent.com/uselibrary/Getting-Started-with-Linux/main/images/nano_ctrl_e.jpg"                      alt="nano_ctrl_e"                ></p><p><code>Y</code>则保存，<code>N</code>则不保存，<code>Ctrl+C</code>取消操作。此处输入<code>Y</code>，则会如下图：</p><p><img                       lazyload                     alt="image"                     data-src="https://raw.githubusercontent.com/uselibrary/Getting-Started-with-Linux/main/images/nano_yes.jpg"                      alt="nano_yes.jpg"                ></p><p>此时按下<code>Enter</code>键就会保存了。</p><p>这里多提一句关于Debian 11的更新源内容，一般是以下6行。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb http://deb.debian.org/debian bullseye main contrib non-free</span><br><span class="line">deb-src http://deb.debian.org/debian bullseye main contrib non-free</span><br><span class="line"></span><br><span class="line">deb http://deb.debian.org/debian-security/ bullseye-security main contrib non-free</span><br><span class="line">deb-src http://deb.debian.org/debian-security/ bullseye-security main contrib non-free</span><br><span class="line"></span><br><span class="line">deb http://deb.debian.org/debian bullseye-updates main contrib non-free</span><br><span class="line">deb-src http://deb.debian.org/debian bullseye-updates main contrib non-free</span><br></pre></td></tr></table></figure><p>deb表示为已经编译好的安装包，类似于Windows上的MSI安装包，deb-src是源文件，万一没有打包好，提供自己本地编译安装的机会。总共分三大行，第一行是系统主文件，第二行是安全性更新，第三个是一些更新补充，推荐三个都写上。在每行的末尾都有<code>main contrib non-free</code>字样，其中<code>main</code>是官方给的包&#x2F;源，严格遵守相关开源协议；<code>contrib</code>是包&#x2F;源本身遵守相关开源协议，但是它们的依赖则不是；<code>non-free</code>是私有的软件，比如上文提到的Realtek的WiFi驱动等。除此之外，其实还有个<code>Backports</code>作为第四大行，是将比较陈旧的软件移植过来的，很少会用到，一般默认不写上。</p><p>nano虽然好，但是功能简单，只适合一些简单的文本文件编辑功能，而发展自vi的vim则被成为编辑器之神（Emacs被称为神之编辑器，Linux之父Linus Torvalds就在用）。系统会自带vi但是不带vim，正好我们可以使用上述修改过的更新源来安装vim作为示例。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt update # 更新一下源</span><br><span class="line">apt install vim -y #安装vim这个软件 -y是确认安装</span><br></pre></td></tr></table></figure><p>使用<code>vim /etc/apt/sources.list</code>打开更新源文件，如下图所示：</p><p><img                       lazyload                     alt="image"                     data-src="https://raw.githubusercontent.com/uselibrary/Getting-Started-with-Linux/main/images/vim_ui.jpg"                      alt="vim_ui"                ></p><p>vim功能众多，使用复杂，得慢慢说。左下角是此文件的路径和名称，右下角是光标此时的行数和列数。此时是无法直接输入，要先按下<code>insert</code>或者<code>i</code>键变成插入模式才行。此时，左下角如下图，变成了INSERT&#x2F;插入模式。</p><p><img                       lazyload                     alt="image"                     data-src="https://raw.githubusercontent.com/uselibrary/Getting-Started-with-Linux/main/images/vim_s1.jpg"                      alt="vim_s1"                ></p><p>然后就是该怎么写就怎么写，一些快捷键去百度谷歌必应吧，说的肯定比我详细。但是必须提到如何保存文件：<code>insert</code>模式下按<code>esc</code>键（一般是键盘最左上角，99%的人可能都不怎么用的一个键），INSERT会消失不见，如下图：</p><p><img                       lazyload                     alt="image"                     data-src="https://raw.githubusercontent.com/uselibrary/Getting-Started-with-Linux/main/images/vim_s3.jpg"                      alt="vim_s3"                ></p><p>这个时候再按下<code>:</code>键，界面上也会出现一个冒号，如下图。注意，这个冒号是半角的，全角冒号是没用的。</p><p><img                       lazyload                     alt="image"                     data-src="https://raw.githubusercontent.com/uselibrary/Getting-Started-with-Linux/main/images/vim_s2.jpg"                      alt="vim_s2"                ></p><p>这个时候，按下<code>wq</code>这两个键，即可保存内容。w是write&#x2F;写入的意思，q是quit&#x2F;退出的意思。如果你不想保存，则只输入q键即可，但是有时候因为文件已经被修改了，vim不让退出，这时候输入<code>q!</code>就可以了，感叹号是强制执行的意思，执行后文件不会被修改并且会退出vim。</p><h3 id="1-4-更新系统"><a href="#1-4-更新系统" class="headerlink" title="1.4 更新系统"></a>1.4 更新系统</h3><p>至此，不管是使用nano还是vim都可以对更新源进行编辑了，让我们来具体了解一下如果更新系统和相关指令。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt list --upgradable</span><br><span class="line">apt upgrade -y</span><br></pre></td></tr></table></figure><p>以上三行，分别是和更新源同步，显示出哪些软件可以更新，以及进行更新。</p><p>如上文中，安装了vim，若想卸载vim，则有以下两个命令，任意一个即可，但之间存在差别。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt remove vim -y</span><br><span class="line">apt purge vim -y</span><br></pre></td></tr></table></figure><p>第一个会址卸载vim软件本身，配置文件仍然会本留下；第二种连带着配置文件和相关依赖一起卸载了，所以存在一定风险。除此之外，<code>apt autoremove</code>是对整个系统进行整理，将不需要的依赖卸载了，不针对于特定软件。</p><h2 id="2-SSH连接和基础配置"><a href="#2-SSH连接和基础配置" class="headerlink" title="2 SSH连接和基础配置"></a>2 SSH连接和基础配置</h2><p>一般VPS供应商都会提供SSH的链接方式，包括用户名，密码和端口号，一些注重安全性的会修改端口号甚至只有采用密钥才能登陆VPS。这里使用纯净版的系统和默认配置进行演示。</p><h3 id="2-1-连接SSH的软件和相关操作"><a href="#2-1-连接SSH的软件和相关操作" class="headerlink" title="2.1 连接SSH的软件和相关操作"></a>2.1 连接SSH的软件和相关操作</h3><p>SSH软件有开源的和不开源的，有付费的和免费的，整理了一个常见SSH客户端（Windows平台）的对比表格和相关信息。其实在2021年，macos、Linux和windows 10都自带SSH功能，这里先不讨论。个人目前主用mobaxterm，偶尔使用xshell。</p><table><thead><tr><th>名称</th><th>免费与否</th><th>下载地址</th></tr></thead><tbody><tr><td>Xshell</td><td>家庭&#x2F;学校免费</td><td><a class="link"   href="https://www.netsarang.com/zh/free-for-home-school/" >https://www.netsarang.com/zh/free-for-home-school/<i class="fas fa-external-link-alt"></i></a></td></tr><tr><td>MobaXterm</td><td>家庭版免费</td><td><a class="link"   href="https://mobaxterm.mobatek.net/download.html" >https://mobaxterm.mobatek.net/download.html<i class="fas fa-external-link-alt"></i></a></td></tr><tr><td>FinalShell</td><td>基础功能免费</td><td><a class="link"   href="https://www.hostbuf.com/t/988.html" >https://www.hostbuf.com/t/988.html<i class="fas fa-external-link-alt"></i></a></td></tr><tr><td>electerm</td><td>免费+开源</td><td><a class="link"   href="https://github.com/electerm/electerm/releases" >https://github.com/electerm/electerm/releases<i class="fas fa-external-link-alt"></i></a></td></tr><tr><td>PuTTY</td><td>免费+开源</td><td><a class="link"   href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html" >https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html<i class="fas fa-external-link-alt"></i></a></td></tr></tbody></table><p>Xshell：传播广泛，自带中文，个人使用完全免费，但是会话窗口限制最多只能打开四个SSH连接，再多之后就会自动新建会话窗口了，传输文件需要配合Xftp才行。目前国区被臭名昭著的思杰马克丁代理了，如需使用，请前往官网下载，在输入邮件和姓名后，会收到一封邮件，邮件里面给出下载连接。</p><p>MobaXterm：只有英文版本，偶尔会反应慢半拍，除此之外没缺点。功能极其强大，传输文件、性能监控、串口通信、X11支持、IP检测、宏、WSL、远程桌面等，能想到的功能都有，而且个人使用免费。</p><p>FinalShell：国人开发，所以本地化很好，全中文，日常需要的功能也都有。有一些进阶功能需要付费，也可以云端保存SSH账号，虽然也是付费功能。缺点的话，和MobaXterm一样，JAVA写的东西，总是让人觉得慢半拍。</p><p>electerm：日常所需功能都有，完全开源和免费，还可以通过GitHub实现免费的云端保存SSH账号功能，适合自己折腾和魔改。基于electron开发的，从而实现了跨平台，Windows、Mac和Linux都有客户端。不过缺点也显而易见，electron本质上是个浏览器，占内存和硬盘空间。</p><p>PuTTY：由Simon Tatham开发和维护的，老牌中的老牌，但是缺少人性化设置，不推荐。</p><h3 id="2-2-SSH配置文件介绍和修改"><a href="#2-2-SSH配置文件介绍和修改" class="headerlink" title="2.2 SSH配置文件介绍和修改"></a>2.2 SSH配置文件介绍和修改</h3><p>SSH的配置文件在<code>/etc/ssh/sshd_config</code>中，是一个纯文本文件，可以使用<code>nano</code>或者<code>vim</code>打开和编辑。打开文件后，在前几行就能看到<code>#Port 22</code>字样，这个代表使用了默认的22端口作为SSH连接使用。因为大家都在使用22端口，所以会有一些扫描机器使用弱密码不断尝试登录，使用<code>lastb</code>命令可以查看登录失败的记录，如下图。233333是尝试登录的账号，144.214.xxx.xxx是发起者的IP，最后面是尝试登录的时间。</p><p><img                       lazyload                     alt="image"                     data-src="https://raw.githubusercontent.com/uselibrary/Getting-Started-with-Linux/main/images/ssh_lastb.jpg"                      alt="ssh_lastb"                ></p><p>因此，我们可以改成高端口，比如<code>35261</code>这种没有特殊含义&#x2F;排列的随机数，以减小被攻击的可能。要注意端口只能在0-65535之间，并且很多低位数的端口，已经被共识的程序占领了，比如80端口是http的，443端口是https的，就如22是SSH的一样。此处，我们修改<code>/etc/ssh/sshd_config</code>中的端口数后，还需要重启SSH服务才行，否则只会在系统下次重启后才启用新的端口。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart ssh #重启SSH服务</span><br></pre></td></tr></table></figure><p><code>systemctl</code>是systemd的命令，用于启动和监控系统服务的，在系统内核启动后，systemd就会开始服务，<code>restart</code>即重启的意思。关于systemd的相关内容，后文会详细说明。</p><p>除此之外，把密码改的复杂一些，也可以有效的降低系统被黑的风险，使用<code>passwd root</code>命令，即可修改root账号的密码，会提示<code>New password:</code>，此时输入新密码，注意这里是看不见任何输入反馈的，随后在显示<code>Retype new password:</code>后再次输入一遍，如果两次密码相同，就会更新root密码了。</p><h3 id="2-3-使用密钥登陆SSH"><a href="#2-3-使用密钥登陆SSH" class="headerlink" title="2.3 使用密钥登陆SSH"></a>2.3 使用密钥登陆SSH</h3><p>即使更改了端口，但因为使用密码即可登录，考虑到不是所有人都会使用强密码，所以SSH提供了使用密钥登录的功能，可以简单理解成是一长串复杂的并且可以相互验证的密码。以root用户为例，演示如何将SSH由密码登录改成密钥登录。</p><p>输入<code>ssh-keygen -t rsa </code>，随后一路enter键，如下图</p><p><img                       lazyload                     alt="image"                     data-src="https://raw.githubusercontent.com/uselibrary/Getting-Started-with-Linux/main/images/ssh_key.jpg"                      alt="ssh_key"                ></p><p>在显示完成后，在<code>/root/.ssh/</code>文件夹下，你将看到<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，id_rsa是私钥，下载下来并妥善保存，id_rsa.pub是公钥，放在服务器上的。将id_rsa.pub写入到SSH的密钥文件中：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch authorized_keys</span><br><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure><p>除此之外，还需要给文件和相关文件夹合适的权限：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 600 authorized_keys</span><br><span class="line">chmod 700 ~/.ssh</span><br></pre></td></tr></table></figure><p>这里有个<code>~</code>，它代表的是<code>当前用户</code>，比如现在是root用户，那<code>~</code>就是<code>root</code>，所以<code>chmod 700 ~/.ssh</code>等于<code>chmod 700 /root/.ssh</code></p><p>现在密钥已经配对好了，还需要修改SSH的配置文件，打开<code>/etc/ssh/sshd_config</code>文件，查找并修改如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PubkeyAuthentication yes # yes表示允许密钥登陆</span><br><span class="line">AuthorizedKeysFile      .ssh/authorized_keys .ssh/authorized_keys2 # 指定密钥的文件位置，这里是去掉了开头的#</span><br><span class="line">PasswordAuthentication no # 不允许使用密码登陆，等测试密钥登陆成功了再修改此条，以防无法登陆</span><br></pre></td></tr></table></figure><p>使用<code>systemctl restart ssh</code>重启SSH服务，此刻，你将只能使用密钥才能登录，一旦私钥遗失了，就再也进不去了。</p><h2 id="3-Linux文件系统"><a href="#3-Linux文件系统" class="headerlink" title="3 Linux文件系统"></a>3 Linux文件系统</h2><h3 id="3-1-文件系统格式"><a href="#3-1-文件系统格式" class="headerlink" title="3.1 文件系统格式"></a>3.1 文件系统格式</h3><p>与Windows分割硬盘（甚至一个硬盘被划分成了好几个）不同，Linux的是将所有硬盘都<code>挂载</code>在了一起。简单来说，Windows分C盘D盘等，还针对软盘额外给予了A盘和B盘，Linux把所有的硬盘都放在了<code>/</code>下，即<code>根目录</code>，这也是Linux中root账户的权限最大的原因，<code>root</code>即为根，如同树根一样，所有的内容都要基于根才有了可能。文件系统是另外一个极其复杂的内容，这里只提到Windows使用的是NTFS，而Linux普遍采用EXT4格式，这两种文件系统互不兼容，装在Linux系统上的硬盘，在Windows上是无法直接读写的，必须使用额外的软件才能访问。反过来，在Linux上读取Windows下的硬盘中的内容，需要安装<code>ntfs-3g</code>才行。这两种文件系统各有优缺点，一般人用就行了，不要问，问就是用默认。实际上，目前在广泛使用的文件系统种类繁多，所有需要在它们之间交换文件的时候，会使用exFAT格式的U盘&#x2F;硬盘（exFAT是FAT的替代品，因为FAT下单个文件最大不能超过4G）。</p><h3 id="3-2-文件树、文件夹功能和权限"><a href="#3-2-文件树、文件夹功能和权限" class="headerlink" title="3.2 文件树、文件夹功能和权限"></a>3.2 文件树、文件夹功能和权限</h3><p>在<code>/</code>目录下，使用<code>ls -la</code>会显示出所有的文件和文件夹（如下图所示），<code>a</code>是列出所有文件，<code>l</code>是显示详细信息。</p><p><img                       lazyload                     alt="image"                     data-src="https://raw.githubusercontent.com/uselibrary/Getting-Started-with-Linux/main/images/root_files.jpg"                      alt="root_files"                ></p><p>第一列是文件&#x2F;文件夹的权限，一共有10个字符，第一位是文件类型，比如d代表文件夹，l代表链接。之后，三个为一组，总共3组。r是读，w是写，x是执行，也可以通过数字来区分，r是4，w是2，x是1，所以有了常见的一把梭<code>chmod +777</code>。第二列是硬链接数量，即这个文件&#x2F;文件夹下有多少真实放着的文件。第三列和第四列是这个件分别属于谁，以及这个人是哪个组的。这里的<code>组</code>概念来源于最开始的unix是个多用户系统，所有会把用户分类，比如某软件用户放一个组，系统维护人员放一个组等。第六列是文件&#x2F;文件夹大小，默认单位是K。第七八九列是修改的日期。最后一列是文件&#x2F;文件夹的名字。我们会发现有一些<code>-&gt;</code>的字样，这是指软链接。软连接类似于Windows上的快捷方式，而硬连接类似于复制了一份（但并不会真的占用空间）。</p><ul><li>bin或者usr&#x2F;bin：应用程序，比如Python的主程序就在这里</li><li>boot：系统启动文件</li><li>dev：外部硬件设备，Linux下一切皆文件，所以外部硬件设备也是以文件形式出现</li><li>etc：系统的配置文件，比如上述提到的SSH的配置文件就在这里</li><li>home：用户目录，类似于Windows上的桌面</li><li>initrd.img：启动文件，可以看到它被软连接到了boot目录中</li><li>lib：库文件，类似于Windows的dll，程序的依赖都在这里</li><li>lost+found：丢失寻找文件，系统被强迫关机后，会在这里记录下来</li><li>media：媒体文件，如果系统发现了光盘之类的，会自动挂载到这里</li><li>mnt：临时挂载目录，上述的光盘，还有U盘硬盘，如果手动挂载，都会选择这里</li><li>opt：系统额外软件的安装位置，极少使用，比如甲骨文的数据库会放一些东西在这里</li><li>proc：系统进程&#x2F;内核会把一些信息放到这里，本质上是反应系统状态而不是文件</li><li>root：root用户的“桌面”，普通用户在home中</li><li>run：系统启动后存放临时文件</li><li>sbin：root用户的”bin”</li><li>srv：放服务运行而需要的文件</li><li>sys：文件系统，里面包括进程信息，设备信息和终端信息</li><li>tmp：临时文件</li><li>usr：共享资源，类似于Windows安装软件的默认目录</li><li>var：不断变化的文件会放在这里，比如日志</li><li>vmlinuz：启动文件，可以看到它被软连接到了boot目录中</li></ul><p>如果我们自己写了一个程序，还放在系统里面运行，那一般是在<code>/usr/local/</code>中新建目录，这遵循着Linux系统的默认规则。</p><h3 id="3-3-示例：挂载U盘"><a href="#3-3-示例：挂载U盘" class="headerlink" title="3.3 示例：挂载U盘"></a>3.3 示例：挂载U盘</h3><p>如果是Ubuntu桌面的话，会自动挂载U盘，但是无GUI版本的Linux大概率不会，所以会需要手动挂载，又或者加了一块新的硬盘，需要我们自己挂载。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fdisk -l</span><br><span class="line">mkdir /mnt/usb</span><br><span class="line">mount /dev/sda1 /mnt/usb</span><br><span class="line">umount /mnt/usb</span><br></pre></td></tr></table></figure><p><code>fdisk -l</code>是显示出所有的储存，会显示出来类似于<code>/dev/sda1</code>等，<code>mkdir /mnt/usb</code>在<code>mnt</code>目录里面新建一个文件夹，即挂载点，假设<code>sda1</code>就是我们插入的U盘，<code>mount /dev/sda1 /mnt/usb</code>将这块U盘挂载到了<code>/mnt/usb</code>中，这时候我们就能在<code>/mnt/usb</code>中看到U盘里的文件。如果不再需要了，要手动移除这个U盘，使用<code>umount /mnt/usb</code>命令。</p><h2 id="4-Shell-x2F-Dash入门"><a href="#4-Shell-x2F-Dash入门" class="headerlink" title="4 Shell&#x2F;Dash入门"></a>4 Shell&#x2F;Dash入门</h2><p>让人头大，Shell本身就能写一本书了，少说得有300页！这里面夹杂着从Unix开始的一大堆事情，shell的发展，bash和dash的区别与联系，本身的命令，调用系统的命令，交互方式。累了，姑且先把它当成一堆命令拼凑起来的脚本吧。</p><p>还是写个例子，简单介绍一下实际内容，等以后有时间了再继续补充。比如我们想写一个查看CPU和内存使用率的脚本：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;which useage do you want to konw?&quot;</span><br><span class="line">echo &quot;1 for CPU, 2 for RAM&quot;</span><br><span class="line">read choice</span><br><span class="line"></span><br><span class="line">if [ $choice -eq 1 ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;CPU usage&quot;</span><br><span class="line">   grep &#x27;cpu &#x27; /proc/stat | awk &#x27;&#123;usage=($2+$4)*100/($2+$4+$5)&#125; END &#123;print usage &quot;%&quot;&#125;&#x27;</span><br><span class="line">elif [ $choice -eq 2 ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;RAM usage&quot;</span><br><span class="line">   free -m | grep Mem | awk &#x27;&#123;print ($3/$2)*100 &quot;%&quot;&#125;&#x27;</span><br><span class="line">else</span><br><span class="line">   echo &quot;WRONG INPUT&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>细说每一行内容</p><p><code>#!/bin/bash</code>是指定此文件由&#x2F;bin下面的bash这个程序来执行。</p><p>在Debian 11里面，bash其实是dash，别问dash是什么，就写bash，天王老子来了也写bash。Bash全称是GNU Bourne-Again Shell，bash被从NetBSD（一个Unix的分支）上移植到Debian上，所以叫dash (Debian Almquist Shell)。</p><p><code>echo &quot;which useage do you want to konw?&quot;</code>是输出冒号内的文字</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;1 for CPU, 2 for RAM&quot;</span><br><span class="line">read choice</span><br></pre></td></tr></table></figure><p>把输入内容赋值给<code>choice</code>这个变量，即数字1或者2。<code>rcho -p &quot;1 for CPU, 2 for RAM&quot; choice</code>也可以实现相同功能。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ ... ]</span><br><span class="line">then</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">elif [ ... ]</span><br><span class="line">then</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">else</span><br><span class="line">...</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>这是一个if…elif…else的判断语句，先经过两次判断，如果都不能成功，那就执行最后一行。</p><p><code>$choice -eq 1</code>把刚才的<code>choice</code>这个输入变量和数字1对比，注意，要有<code>$</code>才代表变量，不然就默认是文字，<code>-eq</code>是等于的意思。判断是否等于1，是的话就给出CPU使用量，如果不等于1，那就继续判断是否等于2，是的话就给出RAM使用量，如果不等于2，那就输出错误提醒，然后结束。<code>grep</code>是抓取有关键词的那一行，<code>$2</code>是这一行的第几个内容，如下：</p><p><img                       lazyload                     alt="image"                     data-src="https://raw.githubusercontent.com/uselibrary/Getting-Started-with-Linux/main/images/grep.jpg"                      alt="grep"                ></p><p><code>grep Mem</code>抓取到了第二行，即真实内存这一行，<code>$2</code>是内存总量，<code>$3</code>是已经使用了的内存，因此<code>($3/$2)*100</code>就是已经使用了百分之多少的内存，</p><h2 id="5-Crontab定时任务"><a href="#5-Crontab定时任务" class="headerlink" title="5 Crontab定时任务"></a>5 Crontab定时任务</h2><p>Crontab用于定时任务，比如设定周五晚上运行脚本备份网站，又或者每分钟检查一下CPU使用率等。但除此之外，crontab还有个<code>@reboot</code>功能，即可以在系统启动的时候自动运行指定程序。</p><p>推荐<code>crontab -e</code>，其中的<code>-e</code>是指当前用户，不建议直接使用<code>crontab</code>。首次运行<code>crontab -e</code>的时候，会让选择使用何种编辑工具，这个随便，nano和vim basic都行，什么顺手和习惯就用什么。</p><p><img                       lazyload                     alt="image"                     data-src="https://raw.githubusercontent.com/uselibrary/Getting-Started-with-Linux/main/images/crontab_eg.jpg"                      alt="crontab_eg"                ></p><p>如上图，将每隔15分钟，就会使用位于<code>usr/bin</code>中的<code>python3</code>运行位于<code>/usr/local/weather</code>中的<code>weather.py</code>程序。前五个星号其实是设置的时间，推荐去 <a class="link"   href="https://crontab.guru/" >https://crontab.guru/<i class="fas fa-external-link-alt"></i></a> 这里直接设置时间（如下图）。第一个星号是分钟，第二个星号是小时，第三个星号是天，第四个星号是月份，第五个星号是每周的第几天。</p><p><img                       lazyload                     alt="image"                     data-src="https://raw.githubusercontent.com/uselibrary/Getting-Started-with-Linux/main/images/crontab_set.jpg"                      alt="crontab_set"                ></p><h2 id="6-系统权限"><a href="#6-系统权限" class="headerlink" title="6 系统权限"></a>6 系统权限</h2><h3 id="6-1-root和user，以及sudo"><a href="#6-1-root和user，以及sudo" class="headerlink" title="6.1 root和user，以及sudo"></a>6.1 root和user，以及sudo</h3><p>上述已经简单的减少了root来源，由于root的权限太高，以至于在实际使用中发现并不安全，而且作为一个初始目的是多用户多终端的操作系统，Linux主要操作都不需要发生在root用户上的。所以这里就有了user这个角色，如果用户多了起来，为了便于管理，也会把某些用户分组，就有了group的概念。以下演示使用root用户新建一个user用户并进入此用户：</p><p><img                       lazyload                     alt="image"                     data-src="https://raw.githubusercontent.com/uselibrary/Getting-Started-with-Linux/main/images/adduser.jpg"                      alt="adduser"                ></p><p>如图所示，<code>adduser mjj</code>为新建一个叫做mjj的用户，由于此前并没有除了root之外的用户，所以会使用这个名字作为group&#x2F;组的名字，并且在&#x2F;home文件夹里面生成一个mjj文件夹，即mjj的”桌面“。所以输入两次密码，之后会问一堆问题，都是例行的，一路enter就好，最后会问一下信息对不对，输入y就完成添加新用户了。</p><p>但此时，mjj这个用户的权限是很小的，四舍五入等于没有，连某些文件夹都不能进去更别说执行软件了。使用<code>su mjj</code>切换到mjj用户中，可以在终端中看到已经从root@rn变成了mjj@rn，rn是这台服务器的名字，即为某某在rn这台服务器上。查看以下root文件夹下有些什么东西，结果发现权限不够而被拒绝访问&#x2F;Permission denied。</p><p><img                       lazyload                     alt="image"                     data-src="https://raw.githubusercontent.com/uselibrary/Getting-Started-with-Linux/main/images/sudo.jpg"                      alt="sudo"                ></p><p>所以我们要给一个能够临时使用root权限的能力，这被称为<code>sudo</code>。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su root #切换回root账号</span><br><span class="line">apt install sudo -y #有些时候，纯净安装的Debian系统是没有sudo的，所以要安装一下</span><br><span class="line">usermod -aG sudo mjj ##给予mjj用户sudo权限</span><br></pre></td></tr></table></figure><p>此时，我们再切换到mjj用户上，在刚才的命令前加上sudo，临时获取root权限，就可以查看了：</p><p><img                       lazyload                     alt="image"                     data-src="https://raw.githubusercontent.com/uselibrary/Getting-Started-with-Linux/main/images/sudo_root.jpg"                      alt="sudo_root"                ></p><p>在用户首次使用root权限的时候，系统会提示三个准则，也请谨记：</p><ol><li>尊重他人隐私；</li><li>输入之前请三思；</li><li>能力越大，责任越大。</li></ol><h3 id="6-2-chmod和chown"><a href="#6-2-chmod和chown" class="headerlink" title="6.2 chmod和chown"></a>6.2 chmod和chown</h3><p>chmod的全称是change mode，是针对于文件夹或者文件，改变它们的权限，这样就可以让某些用户正常使用了。这里不深入探讨chmod的使用详解，仅演示一些常见的内容。<code>chmod +x helloworld.py</code> 这里的<code>x</code>在上面说过，是执行的意思，即赋予此程序被执行的权限，多见于一键脚本里面，让脚本能够正常运行。<code>+</code>是新增权限，如果是<code>-</code>则是去除对应的权限。<code>chmod -R 755 folder/</code> <code>-R</code>如上述的<code>rm -rf</code>中的<code>r</code>一样，是递归，即从这里开始，下面不论多少层文件夹，都执行这个命令。<code>755</code>是换算下来，则是root用户可以读写执行（1+2+4&#x3D;7），用户和用户组只能读和执行（1+4&#x3D;5），不能对文件进行更改。某些程序会对文件的权限有着极其严重的控制，比如上说的SSH密钥，分别给<code>authorized_keys</code>600的权限和<code>.ssh</code>文件夹700的权限，意味着只能被所有者&#x2F;owner读写，在例子中即为只能被root账户读写。这种设计让没有相应权限的人无法修改密钥登陆的方式，换而言之，隔绝了用户之间的操作，从而增强安全性。</p><p>chown的全称是change owner，是用于设置文件所有权的。由于<code>归属者</code>的概念并没有文件这个概念常见，所有chown比较少见到，大多数人接触到的时候，大概是建网站的时候用<code>chown -R www-data:www-data-group /var/www/html</code>来确定文件关联。这句的意思是，将<code>/var/www/html</code>这个文件夹及里面的所有文件都归给<code>www-data-group</code>用户组的<code>www-data</code>用户。这样做的目的是实现权限分离，文件分离，从而让服务器可以更方便的被维护，以及明确使用途径。不过考虑到mjj大部分都是使用VPS的，可能很难遇到需要chown的情况吧。</p><p>不要<code>chmod +777</code>！不要<code>chmod +777</code>！不要<code>chmod +777</code>！<strong>人才是服务器安全的最大漏洞！</strong></p><h2 id="7-Systemd入门和配置"><a href="#7-Systemd入门和配置" class="headerlink" title="7 Systemd入门和配置"></a>7 Systemd入门和配置</h2><h3 id="7-1-开机自启和进程守护"><a href="#7-1-开机自启和进程守护" class="headerlink" title="7.1 开机自启和进程守护"></a>7.1 开机自启和进程守护</h3><p>Systemd是由Redhat家的Lennart Poettering开发的，其人以创造性和不靠谱闻名，Systemd在最开始的时候，和init相比没有明显优势，经过多次迭代才有了今天的稳定性和适用性，现在就让老旧的init进入历史垃圾桶吧。事实上，在Linux系统启动的时候，一旦kernel运行了，Systemd就会跟随启动，之后由Systemd唤醒并维护各个程序的正常运行，比如网卡，显示器，SSH服务等。你会在<code>/etc/systemd/system/</code>文件夹中发现一个叫做<code>sshd.service</code>的文件，并且还是enable模式的，这意味着SSH是<code>开机自启</code>的，并且系统会一直监控这这个程序，如果程序崩溃，系统会尝试自动重启它以确保能够正常运行。</p><p>以著名的内网穿透<code>frp</code>的服务器端的Systemd文件为例（下节将详细介绍如何搭建frp），将<code>frps.service</code>放到<code>/etc/systemd/system/</code>文件夹中，使用以下命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable frps.service</span><br><span class="line">systemctl start frps.service</span><br><span class="line">systemctl status frps.service</span><br><span class="line">systemctl restart frps.service</span><br></pre></td></tr></table></figure><p>systemctl是systemd在系统中的程序名字，enable是指让这个程序能够开机自启，start为让程序现就运行，status是查看这个程序现在的状态，restart是重启程序。</p><p>当然，我们也可以自己写systemd的service文件，这里以 <a class="link"   href="https://github.com/cnsilvan/UnblockNeteaseMusic" >https://github.com/cnsilvan/UnblockNeteaseMusic<i class="fas fa-external-link-alt"></i></a> 解锁网易云音乐的程序做参考</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=UnblockNeteaseMusic</span><br><span class="line">After=network.target</span><br><span class="line">Wants=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">WorkingDirectory=/usr/local/UnblockNeteaseMusic</span><br><span class="line">ExecStart=/usr/bin/node app.js -e http://music.163.com -s -p 8888</span><br><span class="line">RestartPreventExitStatus=23</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>一共分为三组，分别为Unit，Service和Install。Unit是这个服务的名称，示例中为<code>UnblockNeteaseMusic</code>而<code>After</code>和<code>Wants</code>指明的<code>network.target</code>意味希望这个程序在网络服务启动后再启动，毕竟是个网络功能，不能还没有网就启动了。Service是核心部分，<code>Type</code>指定了类型,<code>Simple</code>是默认的类型，发现有网了就启动。此外，常见的还有<code>fork</code>和<code>idle</code>，前者意味着程序依赖于另外一个程序的运行，通常还会配置<code>PIDFile</code>，后者是等系统空闲了再启动，属于一点都不急的。<code>WorkingDirectory</code>是工作目录，<code>ExecStart</code>是执行的命令，实例中，是用位于<code>/usr/bin/</code>的nodejs执行位于工作目录的<code>app.js</code>这个文件，并且还带了参数<code>http://music.163.com -s -p 8888</code>。<code>RestartPreventExitStatus</code>是指如果报错信息为<code>23</code>则不会再重启了，具体报错信息是运行的程序决定的。<code>Restart=always</code>指只要不是23的报错信息，那就一旦服务停了，Systemd就会去重启。最后一部分，Install中的<code>WantedBy=multi-user.target</code>指网络服务已经正常启动，也可以让用户登录了，但是并没有开启GUI服务，这个部分不用去探究。</p><h3 id="7-2-Timer代替Crontab"><a href="#7-2-Timer代替Crontab" class="headerlink" title="7.2 Timer代替Crontab"></a>7.2 Timer代替Crontab</h3><p>我写了一个自动登录百度贴吧并签到的shell脚本，想每天都运行一次帮我拿积分，但是又不想用crontab实现定时任务，那么Systemd也是有类似的功能的，名字叫做Timer，即定时器。这个功能需要两个文件，比较繁琐。</p><p>需要再<code>/etc/systemd/system/</code>中写两份配置文件，<code>tieba.service</code>和<code>tieba.timer</code>，前缀必须一样，后缀不同。</p><p>前者很简单，就是个脚本（如下），名字和程序的路径：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Tieba Sign</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/home/tieba.sh</span><br></pre></td></tr></table></figure><p>后者<code>tieba.timer</code>需要详细解释：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Tieba Sign Timer</span><br><span class="line"></span><br><span class="line">[Timer]</span><br><span class="line">OnCalendar=*-*-* 12:00:00</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=timers.target</span><br></pre></td></tr></table></figure><p>Timer的名称需要是service名字后面加一个Timer，用以提高准确性。<code>OnCalendar</code>类似于<code>corntab</code>的<code>* * * * *</code>，实例中的意味每天中午12点的时候执行以下<code>tieba.service</code>中的位于<code>/home</code>文件夹的<code>tieba.sh</code>这个程序。此处的<code>WantedBy</code>是<code>timers.target</code>，指明是个定时器。</p><h2 id="8-手动配置系统：以frp为例"><a href="#8-手动配置系统：以frp为例" class="headerlink" title="8 手动配置系统：以frp为例"></a>8 手动配置系统：以frp为例</h2><p>frp是个内网穿透软件，可以将局域网设备通过frp服务端映射出来，实现公网服务，常见的有SSH、http&#x2F;https服务等。这里以将内网设备的SSH映射到有公网IP的服务器上为例，从而不在家也能服务家里面的服务器了。</p><p>在这里下载最新版的安装包 <a class="link"   href="https://github.com/fatedier/frp/releases" >https://github.com/fatedier/frp/releases<i class="fas fa-external-link-alt"></i></a> </p><p><img                       lazyload                     alt="image"                     data-src="https://raw.githubusercontent.com/uselibrary/Getting-Started-with-Linux/main/images/frp_tar.jpg"                      alt="frp_tar"                ></p><p>如图所示，0.38.0是版本号；后面的是系统，darwin是MacOS，freebsd是UNIX的一个分支，这里我们选择linux；紧跟着的是CPU架构，由于本次服务器的客户端是装了64位系统的树莓派4B（arm架构的CPU），所以选择<code>frp_0.38.0_linux_arm64.tar.gz</code>，而服务端是普通的VPS，所以选择<code>frp_0.38.0_linux_amd64.tar.gz</code>。</p><p><strong>服务端配置</strong></p><p>注意：版本号和CPU架构须按照实际情况决定。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_linux_amd64.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用wget下载软件包</span></span><br><span class="line">tar -zxvf frp_0.38.0_linux_amd64.tar.gz</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压下载的软件包</span></span><br><span class="line">cd frp_0.38.0_linux_amd64/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入解压后的文件夹</span></span><br><span class="line">mkdir /etc/frp/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个frp的文件夹</span></span><br><span class="line">mv frps.ini /etc/frp/frps.ini</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把服务器端的配置文件放到刚才新建的文件夹</span></span><br><span class="line">mv frps /bin/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把服务器端软件放到/bin中</span></span><br><span class="line">mv systemd/frps.service /etc/systemd/system/frps.service</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">放置Systemd文件</span></span><br><span class="line">systemctl enable frps.service</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置开机自启</span></span><br><span class="line">systemctl start frps.service</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">立即运行</span></span><br></pre></td></tr></table></figure><p><strong>客户端配置</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_linux_arm.tar.gz</span><br><span class="line">tar -zxvf frp_0.38.0_linux_arm.tar.gz</span><br><span class="line">cd frp_0.38.0_linux_arm/</span><br><span class="line">mkdir /etc/frp/</span><br><span class="line">mv frpc.ini /etc/frp/frpc.ini</span><br><span class="line">mv frpc /bin/</span><br><span class="line">mv systemd/frpc.service /etc/systemd/system/frpc.service</span><br></pre></td></tr></table></figure><p>上述与服务器配置类似，就不重复了，但需要额外修改服务端的配置文件，让它知道该和谁连接，打开<code>/etc/frp/frpc.ini</code>配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 服务器ip</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[raspi]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 本地服务器的SSH端口</span><br><span class="line">remote_port = 远程端口</span><br></pre></td></tr></table></figure><p>其中，需要填写服务器端的IP，7000端口是握手和保活用的，默认就好了。<code>[raspi]</code>是客户端的名字，不可以重复，<code>local_port</code>是客户端的SSH端口，<code>remote_port</code>是远程的端口，此处假设是6000。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable frpc.service</span><br><span class="line">systemctl start frpc.service</span><br></pre></td></tr></table></figure><p>设置开机自启并立即运行，此时在SSH软件上，通过 <code>服务器IP:6000 </code>就可以连接到这台内网的树莓派了。</p><h2 id="9-网站环境搭建"><a href="#9-网站环境搭建" class="headerlink" title="9 网站环境搭建"></a>9 网站环境搭建</h2><p>网站搭建，说简单也简单，安装一个nginx放个html页面就算是了，但也可以做的极其复杂以至于需要一个团队，比如淘宝。这里提供了两个搭建网站的方法：面板和手动搭建。对于小白用户，还是推荐用用面板吧，不然出问题，网站被黑都不知道如何解决。</p><h3 id="9-1-宝塔解人忧"><a href="#9-1-宝塔解人忧" class="headerlink" title="9.1 宝塔解人忧"></a>9.1 宝塔解人忧</h3><p>宝塔面板是个伪开源的一键式建站面板，国内版可以在 <a class="link"   href="https://www.bt.cn/" >https://www.bt.cn/<i class="fas fa-external-link-alt"></i></a> 中找到安装方式，目前的安装命令是<code>wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; bash install.sh</code> 。需要注意的是，国内版需要登陆并且验证手机号后才能操作，宝塔也有强制后台升级的前科。</p><p><img                       lazyload                     alt="image"                     data-src="https://raw.githubusercontent.com/uselibrary/Getting-Started-with-Linux/main/images/aapanel.jpg"                      alt="aapanel"                ></p><p>除此之外，还有国际版的叫做aapanel，安装地址为 <a class="link"   href="https://www.aapanel.com/install.html" >https://www.aapanel.com/install.html<i class="fas fa-external-link-alt"></i></a> ，安装命令是<code>wget -O install.sh http://www.aapanel.com/script/install_6.0_en.sh &amp;&amp; bash install.sh</code>。相对而言，国际版的隐私保护会更好一些，不会要求手机号等信息，但是默认语言是英文，如果会哪怕一点点英文，都推荐使用国际版的。</p><p>宝塔有一点不好的地方是动辄编译（原先是在CentOS上开发的，所以有这个臭毛病），面板是python3写的，安装起来很快，但是要安装一些服务的话，如果VPS性能不好，则需要花费相当长一段时间来编译安装，普遍30分钟起步。</p><h3 id="9-2-手动搭建"><a href="#9-2-手动搭建" class="headerlink" title="9.2 手动搭建"></a>9.2 手动搭建</h3><p>宝塔面板是将网站搭建可视化了，本质上和手动搭建没有区别。这里主要是介绍常见的相关软件和Let’s Encrypt配置SSL证书的方法。</p><h4 id="9-2-1-Apache和Nginx"><a href="#9-2-1-Apache和Nginx" class="headerlink" title="9.2.1 Apache和Nginx"></a>9.2.1 Apache和Nginx</h4><p>Apache和Nginx都是Web服务器。前者是老牌Web服务器软件，对PHP有着优秀的支持，并且动态响应优秀，但是对性能和内存要求高。后者是俄罗斯出品，对静态网站支持良好，性能消耗也更小，反代和简单的网站都倾向于使用Nginx，甚至还有一系列基于Nginx衍生出来的版本，比如Tengine就是淘宝从Nginx衍生出来的，用以支撑淘宝的各种服务。除此之外，还有个Caddy也用的比较多，这是由golang语言写出来的，所以对多线程高并发的支持很好，并且自带SSL证书申请的功能。</p><p>入门用户首选Nginx，毕竟网站没有什么服务，对VPS的性能消耗也少点。当然，选择Apache也完全可以，入门用户其实很难用到需要对比选择Apache和Nginx的时候。Caddy的话，先不推荐入门用户了。</p><p>安装Apache使用以下命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install apache2</span><br></pre></td></tr></table></figure><p>安装Nginx使用以下命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install nginx</span><br></pre></td></tr></table></figure><p>这两个软件安装完后，都会开机自启和立刻运行，浏览器中输入<code>http://ip</code>就可以看到默认的网页，比如Nginx的是这样：</p><p><img                       lazyload                     alt="image"                     data-src="https://raw.githubusercontent.com/uselibrary/Getting-Started-with-Linux/main/images/nginx.jpg"                      alt="nginx"                ></p><h4 id="9-2-2-PHP"><a href="#9-2-2-PHP" class="headerlink" title="9.2.2 PHP"></a>9.2.2 PHP</h4><p>安装了Nginx之后，可以实现静态网页，但是常见的网站平台，比如Wordpress和typecho都是PHP写的，所以还需要安装PHP才能运行。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install php-fpm</span><br></pre></td></tr></table></figure><p>安装完php还不算完事，还得让Nginx知道，也就是需要更改Nginx的配置文件。</p><p>进入目录<code>/etc/nginx/sites-available/</code>中，将默认的文件<code>default</code>重命名为网站的域名，比如<code>mjj.hostloc.com</code>，即<code>mv default mjj.hostloc.com</code>，打开<code>mjj.hostloc.com</code>，在下述的第二行末尾加入<code>index.php</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Add index.php to the list if you are using PHP</span><br><span class="line">index index.html index.htm index.nginx-debian.html index.php; # 注意加入了index.php</span><br></pre></td></tr></table></figure><p>并且将下述的<code>_</code>改成网站域名</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server_name _;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">改成 server_name mjj.hostloc.com;</span></span><br></pre></td></tr></table></figure><p>随后，重新软链接，并重启Nginx</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm /etc/nginx/sites-enabled/default</span><br><span class="line">ln -s /etc/nginx/sites-available/mjj.hostloc.com /etc/nginx/sites-enabled/mjj.hostloc.com</span><br><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure><p>注意域名不要填错了，重启完后，Nginx将能够和PHP一起支持动态网站。</p><h4 id="9-2-3-MySQL和MariaDB"><a href="#9-2-3-MySQL和MariaDB" class="headerlink" title="9.2.3 MySQL和MariaDB"></a>9.2.3 MySQL和MariaDB</h4><p>MySQL是一个市场占有率极大的数据库软件，应用场景极其广泛，最开始是SUN公司开发的，2009年被甲骨文收购。甲骨文作恶多端，所以MySQL的一部分作者则独立出来，直接做了一个复刻版的，被命名为MariaDB，Maria是作者女儿的名字，Linux社区逐步放弃MySQL而采用MariaDB。所以在近期发布的各Linux版本中，默认是没有MySQL的，一律采用MariaDB。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install mariadb-server # 安装数据库</span><br><span class="line">mysql_secure_installation # 首次配置</span><br></pre></td></tr></table></figure><p>由于是首次使用，所以在如下提示中，直接enter键就可以了，因为数据库的root用户此时并没有密码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB</span><br><span class="line">      SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!</span><br><span class="line"></span><br><span class="line">In order to log into MariaDB to secure it, we&#x27;ll need the current</span><br><span class="line">password for the root user.  If you&#x27;ve just installed MariaDB, and</span><br><span class="line">you haven&#x27;t set the root password yet, the password will be blank,</span><br><span class="line">so you should just press enter here.</span><br><span class="line"></span><br><span class="line">Enter current password for root (enter for none): </span><br></pre></td></tr></table></figure><p>随后，会询问是否要设置数据库的root密码，怎么说呢，反正就建个站而已（不涉及多用户多服务），有没有无所谓，我习惯性的不设置（输入N）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OK, successfully used password, moving on...</span><br><span class="line"></span><br><span class="line">Setting the root password ensures that nobody can log into the MariaDB</span><br><span class="line">root user without the proper authorisation.</span><br><span class="line"></span><br><span class="line">Set root password? [Y/n] N</span><br></pre></td></tr></table></figure><p>现在，新建一个用户和对应的数据库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql # 进入数据库，如果有root密码，则是mysql -u root -p</span><br><span class="line"></span><br><span class="line">CREATE DATABASE name; # 新建数据库，name是数据库名字</span><br><span class="line">Query OK, 1 row affected (0.00 sec) #此段为mySQL反馈提示，不需要输入。</span><br><span class="line"></span><br><span class="line">CREATE USER user@localhost; # 新建用户，user是用户名字</span><br><span class="line">Query OK, 0 rows affected (0.00 sec) #此段为mySQL反馈提示，不需要输入。</span><br><span class="line"></span><br><span class="line">SET PASSWORD FOR user@localhost= PASSWORD(&quot;密码&quot;); # 给用户设置一个密码</span><br><span class="line">Query OK, 0 rows affected (0.00 sec) #此段为mySQL反馈提示，不需要输入。</span><br><span class="line"></span><br><span class="line">GRANT ALL PRIVILEGES ON name.* TO user@localhost IDENTIFIED BY &#x27;密码&#x27;; # 把name这个数据库和user这个用户关联</span><br><span class="line">Query OK, 0 rows affected (0.00 sec) #此段为mySQL反馈提示，不需要输入。</span><br><span class="line"></span><br><span class="line">FLUSH PRIVILEGES; # 完成设置</span><br><span class="line">exit # 退出数据库</span><br></pre></td></tr></table></figure><h4 id="9-2-4-Let’s-Encrypt，SSL-x2F-TLS"><a href="#9-2-4-Let’s-Encrypt，SSL-x2F-TLS" class="headerlink" title="9.2.4 Let’s Encrypt，SSL&#x2F;TLS"></a>9.2.4 Let’s Encrypt，SSL&#x2F;TLS</h4><p>http连接，由于不是加密的，所以任何人都可以查看内容，这对于一些金融服务有着巨大的危害，比如使用信用卡在网上购物的时候，账号和密码会被获知。所以网景（Firefox浏览器的前身）提出了SSL（安全套接层&#x2F;Secure Sockets Layer）这个概念（后来演变升级为TLS，即传输层安全性协议&#x2F;Transport Layer Security），http变成了https，电脑会内置证书，而网站也会有一个证书，只有两者相互验证成功，才能正常浏览玩网页，并且全程加密（DNS部分并不是加密的，所以有个DoH，dns over https）。</p><p>SSL&#x2F;TLS证书是个垄断行业，电脑内置的证书就那么几家，如果想网站被大多数浏览器&#x2F;系统接受，那就只能去申请其中某家的证书，这里面层层签发转售，几近无本万利。不过好在还是有很多免费的SSL&#x2F;TLS证书的，比如Let’s Encrypt提供三个月的免费证书，而亚洲诚信通过第三方公司，提供一年免费的证书。这里以Let’s Encrypt为例演示，相关链接为 <a class="link"   href="https://certbot.eff.org/instructions" >https://certbot.eff.org/instructions<i class="fas fa-external-link-alt"></i></a> ：</p><p><img                       lazyload                     alt="image"                     data-src="https://raw.githubusercontent.com/uselibrary/Getting-Started-with-Linux/main/images/ssl_tls.jpg"                      alt="ssl_tls"                ></p><p>Let’s Encrypt提供的SSL&#x2F;TLS工具叫做cerbot，可以通过snap或者pip安装。snap是Ubuntu强推的一种软件部署和软件包管理系统，把所有需要的东西都放一起。pip是通过python3的pip安装，pip和snap没有功能上的区别，不想被Ubuntu强推就使用pip。</p><p><strong>snap安装cerbot申请SSL&#x2F;TLS证书</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install snapd</span><br><span class="line">snap install core</span><br><span class="line">snap refresh core</span><br><span class="line">snap install --classic certbot</span><br><span class="line">ln -s /snap/bin/certbot /usr/bin/certbot</span><br><span class="line">certbot --nginx</span><br></pre></td></tr></table></figure><p>然后按照提示，输入邮箱和同意服务协议，并且在提示域名的时候，注意不要输错。</p><p><strong>pip安装cerbot申请SSL&#x2F;TLS证书</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install python3 python3-venv libaugeas0</span><br><span class="line">python3 -m venv /opt/certbot/</span><br><span class="line">/opt/certbot/bin/pip install --upgrade pip</span><br><span class="line">/opt/certbot/bin/pip install certbot certbot-nginx</span><br><span class="line">ln -s /opt/certbot/bin/certbot /usr/bin/certbot</span><br><span class="line">certbot --nginx</span><br><span class="line">echo &quot;0 0,12 * * * root /opt/certbot/bin/python -c &#x27;import random; import time; time.sleep(random.random() * 3600)&#x27; &amp;&amp; certbot renew -q&quot; | sudo tee -a /etc/crontab &gt; /dev/null</span><br></pre></td></tr></table></figure><p>相比于snap自动每三个月更新证书，pip需要通过crontab加一个定时任务（上述最后一行），另外，也需要偶尔检查以下certbot有没有更新，即使用此命令<code>/opt/certbot/bin/pip install --upgrade certbot certbot-nginx</code></p><h2 id="10-Docker快速入门"><a href="#10-Docker快速入门" class="headerlink" title="10 Docker快速入门"></a>10 Docker快速入门</h2><p>Docker的本意是“码头工人”，即搬运别人打包好的集装箱。之所以取这个名字，是因为Docker的功能与此类似：将系统和里面的应用一起打包好，别人“搬走”就能直接使用——可以将Docker粗略的理解成一个包含了系统和应用的虚拟机（严格来说，Docker是使用了沙箱机制的虚拟化容器）。常见的例子就是别人把某一个软件配置好了，用户直接下载下来，简单设置一下就可以使用了，不需要繁杂的配置过程，所以在批量服务中有着广泛的应用场景。Docker分为社区版&#x2F;CE（Community Edition，免费的）和企业版&#x2F;EE（Enterprise Edition，收费的），两者功能无本质区别，以下默认使用社区版。</p><h3 id="10-1-安装Docker环境"><a href="#10-1-安装Docker环境" class="headerlink" title="10.1 安装Docker环境"></a>10.1 安装Docker环境</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt update # 同步更新源</span><br><span class="line">apt install -y ca-certificates curl gnupg lsb-release # 安装必要依赖软件</span><br></pre></td></tr></table></figure><p>添加GPG密钥，注意这里和上面一样，必须是root权限（如下命令）。这里简单介绍一下GPG，全称是GnuPG，真·全称是GNU Privacy Guard，一个密码学软件，用来验证通信中的安全性，防止传输过程中被篡改，前身是Pretty Good Privacy&#x2F;PGP。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/debian/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br></pre></td></tr></table></figure><p>选择使用稳定版，如果需要nightly或者test版，可以把下面的stable改成对应的版本。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable&quot; | tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure><p>更新并安装Docker</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install -y docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><p>期间会下载几百兆的文件，网络不好的话，可能会需要一段时间，当完成安装后，使用<code>docker run hello-world</code>命令来测试功能是否正常，理论上会输出下图内容：</p><p><img                       lazyload                     alt="image"                     data-src="https://raw.githubusercontent.com/uselibrary/Getting-Started-with-Linux/main/images/docker_hello.jpg"                      alt="docker_hello"                ></p><p>至此，系统已经安装好了Docker环境，可以自己写一个Docker的应用，或者直接拉取别人写好的为自己所用。</p><h3 id="10-2-安装别人打包好的的Docker"><a href="#10-2-安装别人打包好的的Docker" class="headerlink" title="10.2 安装别人打包好的的Docker"></a>10.2 安装别人打包好的的Docker</h3><p>先说一下常用的Docker命令，然后以安装Docker版本的Nextcloud为例。Nextcloud是一个开源的网盘系统，类似于私有版本的百度云，可以自己搭建从而确保数据都在自己手上而不会被8秒。</p><h4 id="10-2-1-常用Docker命令"><a href="#10-2-1-常用Docker命令" class="headerlink" title="10.2.1 常用Docker命令"></a>10.2.1 常用Docker命令</h4><p><code>docker ps</code> 列出所有正在运行的容器，如果需要查看所有的容器（包括未运行或者启动失败的）则使用<code>docker ps -la</code>，这点类似于<code>ls</code>和<code>ls -la</code>的区别。</p><p><code>docker start/stop/restart CONTAINER ID</code> 开启&#x2F;停止&#x2F;重启特定容器，后面要加上指定的ID，CONTAINER ID见下文。</p><p><code>docker rm CONTAINER ID</code> 删除容器，如果是删除镜像，则需要把rm换成rmi</p><h4 id="10-2-2-安装Docker版Nextcloud"><a href="#10-2-2-安装Docker版Nextcloud" class="headerlink" title="10.2.2 安装Docker版Nextcloud"></a>10.2.2 安装Docker版Nextcloud</h4><p>在 <a class="link"   href="https://hub.docker.com/" >https://hub.docker.com/<i class="fas fa-external-link-alt"></i></a> 中直接搜索Nextcloud，找到官方版本的镜像，点击进去，在右侧有拉取镜像的命令，直接运行即可。</p><p><img                       lazyload                     alt="image"                     data-src="https://raw.githubusercontent.com/uselibrary/Getting-Started-with-Linux/main/images/docker_nextcloud.jpg"                      alt="docker_nextcloud"                ></p><p>安装过程中会下载各个组件，等全部显示Pull conplete即表示下载完成，之后会自动校验并提示完成。</p><p><img                       lazyload                     alt="image"                     data-src="https://raw.githubusercontent.com/uselibrary/Getting-Started-with-Linux/main/images/docker_pull_nextcloud.jpg"                      alt="docker_pull_nextcloud"                ></p><p>使用<code>docker run -d -p 80:80 nextcloud</code> 运行，此时使用<code>docker ps</code>可以查看到具体的详细信息</p><p><img                       lazyload                     alt="image"                     data-src="https://raw.githubusercontent.com/uselibrary/Getting-Started-with-Linux/main/images/docker_nextcloud_status.jpg"                      alt="docker_nextcloud_status"                ></p><p>CONTAINER ID类似于身份证号码；IMAGE是身份证上的姓名；COMMAND是实际运行的程序；CREATED是创建的时间；STATUS是此时的运行状态；PORTS是端口，上述我们把容器的80端口定向到服务器的80，并且默认ipv4和ipv6都可以访问，接受所有IP的访问（0.0.0.0代表接受所有IP）；NAMES是容器的名字，可以理解为外号。</p><p>之后就是通过IP或者绑定的域名访问，进行最后的安装。这里就能看出来Docker的优势了：用户无需了解具体操作和搭建步骤，提供者负责维护，这可以极大的简化用户的使用步骤，还可以标准化环境，无论使用Debain还是REHL，镜像&#x2F;容器都是提供者给定的。</p><p><img                       lazyload                     alt="image"                     data-src="https://raw.githubusercontent.com/uselibrary/Getting-Started-with-Linux/main/images/docker_nextcloud_install.jpg"                      alt="docker_nextcloud_install"                ></p><p>如果不再需要Nextcloud，则首先停止容器，随后再删除：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop c30d348f1ef1</span><br><span class="line">docker rm c30d348f1ef1</span><br></pre></td></tr></table></figure><h3 id="10-3-建自己的Docker"><a href="#10-3-建自己的Docker" class="headerlink" title="10.3 建自己的Docker"></a>10.3 建自己的Docker</h3><p>Docker通过Unix socket与它的引擎进行通信，出于安全考虑，一般只有root用户和在docker组的用户才能正常访问Unix socket。所以，如果想建一个完善的Docker应用，那么建议额外新增一个用户，并加入docker用户组。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文的首要目的是给予Linux初学者一个简单、易学的教程，以便在看完本文后对Linux系统有一个基础的认识（而非系统级的深入），可以对常见的软件和功能进行配置，甚至可以自己写一写一键脚本。&lt;/p&gt;
&lt;p&gt;本教程写于2021年下半年，采用的系统为Debian GNU&amp;#x2F;Linux 11 (bullseye)。&lt;/p&gt;</summary>
    
    
    
    <category term="liunx" scheme="http://daoke123.github.io/categories/liunx/"/>
    
    
    <category term="mjj" scheme="http://daoke123.github.io/tags/mjj/"/>
    
    <category term="命令" scheme="http://daoke123.github.io/tags/%E5%91%BD%E4%BB%A4/"/>
    
    <category term="linux" scheme="http://daoke123.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>VPS采用Ed25519密钥登录</title>
    <link href="http://daoke123.github.io/2022/05/26/ld7o8d/"/>
    <id>http://daoke123.github.io/2022/05/26/ld7o8d/</id>
    <published>2022-05-25T16:00:00.000Z</published>
    <updated>2022-11-10T14:57:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文抄自：<a class="link"   href="https://github.com/nkypy/blog/issues/17" >https://github.com/nkypy/blog/issues/17<i class="fas fa-external-link-alt"></i></a></p><p>正文前先对比一下：</p><p>3072的RSA的安全性&#x3D;256的ECC(包括ECDSA和25519(EdDSA))</p><p>25519相对于传统NIST P-256曲线的ECDSA效率与速度更快且为确定性签名。</p><span id="more"></span><p>一、本地配置</p><p>1.1 在Windows PowerShell中运行命令</p><p><code>ssh-keygen -t ed25519 -C "oracledubai" # 随便起个名称,本例以oracleduba</code></p><p><code>Enter passphrase (empty for no passphrase):</code></p><p>#对密钥加个私人密码，输入密码或回车留空。</p><p><code>Enter same passphrase again:</code><code># 确认密码或回车。</code></p><p>#显示</p><p><code>Generating public/private ed25519 key pair.Enter file in which to save the key (/home/lenovo/.ssh/id_ed25519): #文件保存位置,一般默认即可。</code></p><p>#显示</p><p><code>Enter passphrase (empty for no passphrase): #对密钥加个私人密码，输入密码或回车留空。<br>Enter same passphrase again:# 确认密码或回车。</code></p><p>#显示</p><pre><code>Your identification has been saved in /home/lenovo/.ssh/id_ed25519 #生成的私钥Your public key has been saved in /home/lenovo/.ssh/id_ed25519.pub #生成的公钥The key fingerprint is:SHA256:PdwszW0JXELbXMuQXDGN+xfKfCMd6YQWEB4 oracledubai #指纹The key's randomart image is:+--[ED25519 256]--+|  Eo.+ . .o ..ooo|| . .= = .  + . +=|| ..= = o  o o . o||o = o o  o B = . ||o+ +    S = B +  ||oo+        o .   ||=  o             ||..o              ||..               |+----[SHA256]-----+</code></pre><ol><li><p>id_ed25519<code>是私钥，</code>id_ed25519.pub是公钥。</p></li><li><p>保存在C:\Users\lenovo.ssh路径中。lenovo为计算机名，不知道是啥的看上面路径home后面的名称。</p></li></ol><p>二、VPS端操作</p><p>2.1 以root登录vps</p><p><code>mkdir /root/.ssh/</code></p><p>2.2 上传公钥</p><p>将id_ed25519.pub上传到&#x2F;root&#x2F;.ssh&#x2F;路径下，并运行</p><p><code>cat /root/.ssh/id_ed25519.pub &gt;&gt;  /root/.ssh/authorized_keys</code></p><p>2.3 修改密钥项</p><p><code>vim /etc/ssh/sshd_config</code></p><p>将下列两行的井号去掉</p><p><code>#PubkeyAuthentication yes    #允许密钥认证</code></p><p><code>#AuthorizedKeysFile    .ssh/authorized_keys .ssh/authorized_keys2    #默认公钥位置</code></p><p><code>service sshd restart #重启sshd</code></p><p>2.4 以密钥方式重新登录</p><p>注意：以密钥方式重新登录</p><p>2.5 关闭密码登录</p><p>运行的前提是：能够密钥登录VPS</p><p><code>vim /etc/ssh/sshd_config</code></p><p>将后面的<code>PasswordAuthentication yes</code></p><p>修改为：<code>PasswordAuthentication no</code></p><p><code>service sshd restart #重启sshd</code></p><p>三、常见的几种密钥生成方式对比</p><p>DSA: 它是不安全的，甚至从OpenSSH第7版开始就不再支持，你需要升级它!</p><p>RSA: 这取决于密钥大小。如果它有3072或4096位的长度，那么你就很好。低于这个长度，你可能要升级它。1024位的长度甚至被认为是不安全的。</p><p>ECDSA：这取决于你的机器能产生一个随机数的程度，这个随机数将被用来创建签名。在ECDSA使用的NIST曲线上也有一个可信度问题。</p><p>#Ed25519: 这是目前最值得推荐的公钥算法!</p><p>转:<a class="link"   href="https://winamp.top/230.html" >https://winamp.top/230.html<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文抄自：&lt;a class=&quot;link&quot;   href=&quot;https://github.com/nkypy/blog/issues/17&quot; &gt;https://github.com/nkypy/blog/issues/17&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;正文前先对比一下：&lt;/p&gt;
&lt;p&gt;3072的RSA的安全性&amp;#x3D;256的ECC(包括ECDSA和25519(EdDSA))&lt;/p&gt;
&lt;p&gt;25519相对于传统NIST P-256曲线的ECDSA效率与速度更快且为确定性签名。&lt;/p&gt;</summary>
    
    
    
    
    <category term="vps" scheme="http://daoke123.github.io/tags/vps/"/>
    
  </entry>
  
  <entry>
    <title>docker mysql容器创建用户密码</title>
    <link href="http://daoke123.github.io/2022/05/18/86/"/>
    <id>http://daoke123.github.io/2022/05/18/86/</id>
    <published>2022-05-17T21:56:21.000Z</published>
    <updated>2022-11-10T14:58:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>#进入 mysql5.7 容器</p><p><code>sudo docker exec -it mysql5.7 bash</code></p><p><code>mysql -uroot -p123456</code></p><p>#创建用户，密码随意</p><p><code>mysql&gt; create user &#39;239239&#39;@&#39;%&#39; identified by &#39;123456&#39;;</code><br><code>mysql&gt; grant all privileges on *.* to &#39;239239&#39;@&#39;%&#39; with grant option;</code><br><code>mysql&gt; flush privileges;</code></p><p>#创建数据库</p><p><code>mysql&gt; create database 239239;</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#进入 mysql5.7 容器&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo docker exec -it mysql5.7 bash&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mysql -uroot -p123456&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;#创建用户，密码随意&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="默认分类" scheme="http://daoke123.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"/>
    
    <category term="网络资源" scheme="http://daoke123.github.io/categories/%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90/"/>
    
    
    <category term="docker" scheme="http://daoke123.github.io/tags/docker/"/>
    
    <category term="mysql" scheme="http://daoke123.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>使用Caddy2作为文件服务器</title>
    <link href="http://daoke123.github.io/2022/05/15/85/"/>
    <id>http://daoke123.github.io/2022/05/15/85/</id>
    <published>2022-05-15T10:22:18.000Z</published>
    <updated>2022-10-30T14:11:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>Caddyfile</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://yourdomain.com &#123;</span><br><span class="line">basicauth &#123;</span><br><span class="line">    bob xDJhJDEwJEVoOWxYTmY5eVdCbXhhRC95SGZoYxU0bVQvaXhyamdLRkxKdUlPSHhLVFY0RWNlRDN5eDx2</span><br><span class="line">&#125;</span><br><span class="line">file_server &#123;</span><br><span class="line">    root /home/share</span><br><span class="line">    browse</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">其中密码应该使用 caddy hash-password 生成</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Caddyfile&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;http://yourdomain.com &amp;#123;&lt;/span&gt;</summary>
      
    
    
    
    <category term="网络资源" scheme="http://daoke123.github.io/categories/%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90/"/>
    
    
    <category term="Caddy" scheme="http://daoke123.github.io/tags/Caddy/"/>
    
  </entry>
  
  <entry>
    <title>github国内设置</title>
    <link href="http://daoke123.github.io/2022/05/12/82/"/>
    <id>http://daoke123.github.io/2022/05/12/82/</id>
    <published>2022-05-12T12:58:15.000Z</published>
    <updated>2022-10-30T14:11:22.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global url.https://xx.xx.xx/.insteadof https://   增加</span><br><span class="line">git config --global --unset url.https://xx.xx.xx/.insteadof https://   取消</span><br><span class="line">git config --global --list  检查</span><br></pre></td></tr></table></figure><p>xx.xx.xx 是代理域名</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git config --global url.https://xx.xx.xx/.insteadof </summary>
      
    
    
    
    <category term="网络资源" scheme="http://daoke123.github.io/categories/%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90/"/>
    
    
    <category term="Github" scheme="http://daoke123.github.io/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>玩客云官方系统ROOT安装哪吒探针</title>
    <link href="http://daoke123.github.io/2022/02/23/80/"/>
    <id>http://daoke123.github.io/2022/02/23/80/</id>
    <published>2022-02-23T15:42:00.000Z</published>
    <updated>2022-10-30T14:11:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>下载哪吒 nezha-agent_linux_arm.tar.gz<br><a class="link"   href="https://github.com/naiba/nezha" >哪吒<i class="fas fa-external-link-alt"></i></a><br>上传ROOT目录给于权限</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 755 nezha-agent</span><br></pre></td></tr></table></figure><p><strong>设置开机自起</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/init.d</span><br><span class="line">touch S96nezha</span><br><span class="line">chmod 755 S96nezha</span><br><span class="line">echo &quot;sleep 10&quot;        &gt;&gt; S96nezha</span><br><span class="line">echo &quot;cd&quot;        &gt;&gt; S96nezha</span><br><span class="line">echo &quot;/root/nezha-agent -s 面板网址:接收端口 -p 唯一秘钥 -d&quot;    &gt;&gt; S96nezha</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>玩客云重启</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下载哪吒 nezha-agent_linux_arm.tar.gz&lt;br&gt;&lt;a class=&quot;link&quot;   href=&quot;https://github.com/naiba/nezha&quot; &gt;哪吒&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;</summary>
      
    
    
    
    <category term="默认分类" scheme="http://daoke123.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>docker filebrowser</title>
    <link href="http://daoke123.github.io/2022/02/18/79/"/>
    <id>http://daoke123.github.io/2022/02/18/79/</id>
    <published>2022-02-18T15:50:00.000Z</published>
    <updated>2022-10-30T14:11:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /home/videos</span><br><span class="line">mkdir /home/videos/cam01</span><br><span class="line">cd</span><br><span class="line">mkdir filebrowser</span><br><span class="line">cd filebrowser</span><br><span class="line">touch filebrowser.db</span><br></pre></td></tr></table></figure><h1 id="运行docker"><a href="#运行docker" class="headerlink" title="运行docker"></a>运行docker</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name filebrowser \</span><br><span class="line">-v /:/srv/ \</span><br><span class="line">-v /root/filebrowser/filebrowser.db:/database.db \</span><br><span class="line">--user $(id -u):$(id -g) \</span><br><span class="line">-p 8088:80 \</span><br><span class="line">--restart=always \</span><br><span class="line">filebrowser/filebrowser</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;创建目录&quot;&gt;&lt;a href=&quot;#创建目录&quot; class=&quot;headerlink&quot; title=&quot;创建目录&quot;&gt;&lt;/a&gt;创建目录&lt;/h1&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="网络资源" scheme="http://daoke123.github.io/categories/%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90/"/>
    
    
  </entry>
  
  <entry>
    <title>自制N1 Docker Openwrt镜像及运行镜像</title>
    <link href="http://daoke123.github.io/2022/02/16/78/"/>
    <id>http://daoke123.github.io/2022/02/16/78/</id>
    <published>2022-02-16T11:48:00.000Z</published>
    <updated>2022-11-10T15:09:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>1.编译openwrt</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Target System 选择 QEMU ARM VIrtual Machine</span><br><span class="line">Subtarget 选择 ARMv8 multiplatform</span><br><span class="line">其它的随意</span><br></pre></td></tr></table></figure><span id="more"></span><ol start="2"><li>编译好的openwrt，会生成 rootfs 打包文件：  <br>openwrt-armvirt-64-default-rootfs.tar.gz</li><li>在装好armbian和docker的N1上，把openwrt-armvirt-64-default-rootfs.tar.gz和Dockerfile放到同一个目录下</li><li>制造镜像<br>(示例用的是openwrt by lean r9.7.6源码，因此镜像名称为：openwrt-arm64 版本为 r9.7.6<br>docker build -t openwrt-arm64:r9.7.6 .<br>即可生成镜像<br>用docker images，可以查看到已生成的镜像<br>用docker save openwrt-arm64:r9.7.6 gzip &gt; docker-image-openwrt-arm64-r9.7.6.tar.gz 可以把镜像导出成打包文件<br>用 gzip -dc docker-image-openwrt-arm64-r9.7.6.tar.gz docker load ，可以把打包文件还原成docker镜像</li><li>运行镜像：<br>可以参见 <a class="link"   href="https://www.jianshu.com/p/e62190cfff1a?tdsourcetag=s_pcqq_aiomsg" >https://www.jianshu.com/p/e62190cfff1a?tdsourcetag=s_pcqq_aiomsg<i class="fas fa-external-link-alt"></i></a><br>重点：<br>a. 物理网卡要开启混杂模式（promisc)，有临时生效型（命令）和永久生效型（要改网络配置文件）<br>b. docker创建macvlan网络<br>c. 用macvlan网络绑定docker容器<br>d. 物理机和openwrt容器在同一网段，但不同ip<br>e. macvlan模式下，物理机和openwrt容器之间是ping不通的，这是正常现象，但第三方电脑都能ping通两者</li></ol><p>示例：</p><p>#docker创建macvlan网络，名为macnet</p><p>docker network create -d macvlan –subnet&#x3D;192.168.3.0&#x2F;24 –gateway&#x3D;192.168.3.1 -o parent&#x3D;eth0 macnet</p><p>#用macnet运行openwrt实例，实例名为phicomm-n1</p><p>#引用armbian的通用函数包</p><p>source &#x2F;usr&#x2F;lib&#x2F;armbian&#x2F;armbian-common</p><p>#得到一个随机MAC地址,存入MACADDR变量</p><p>get_random_mac</p><p>docker run –name phicomm-n1 –restart always –network macnet –mac-address $MACADDR -d –privileged&#x3D;true –ulimit nofile&#x3D;16384:65536 openwrt-arm64:r9.8.17</p><p>#进入op容器，修改&#x2F;etc&#x2F;config&#x2F;network</p><p>docker exec -it phicomm-n1 sh<br>vi &#x2F;etc&#x2F;config&#x2F;network</p><p>修改下面这段：<br>config interface ‘lan’</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">option ifname &#x27;eth0&#x27;</span><br><span class="line">option proto &#x27;static&#x27;</span><br><span class="line">option netmask &#x27;255.255.255.0&#x27;</span><br><span class="line">option gateway &#x27;192.168.3.1&#x27;</span><br><span class="line">option ipaddr &#x27;192.168.3.20&#x27;</span><br><span class="line">option broadcast &#x27;192.168.3.255&#x27;</span><br><span class="line">option ip6assign &#x27;64&#x27;</span><br><span class="line">option dns &#x27;192.168.3.1&#x27;</span><br></pre></td></tr></table></figure><p>注：192.168.3.1是主路由的地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.3.20是openwrt自己的地址，也就是旁路由的地址</span><br><span class="line"> broadcast和dns也做相应更改</span><br></pre></td></tr></table></figure><p>改好后，存盘，运行：<br>&#x2F;etc&#x2F;init.d&#x2F;network restart<br>过一会就可以ping通旁路由了，然后用浏览器连上192.168.3.20就可以按一般的操作了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;1.编译openwrt&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Target System 选择 QEMU ARM VIrtual Machine&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Subtarget 选择 ARMv8 multiplatform&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;其它的随意&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="默认分类" scheme="http://daoke123.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"/>
    
    <category term="网络资源" scheme="http://daoke123.github.io/categories/%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90/"/>
    
    
  </entry>
  
  <entry>
    <title>玩客云当录像机安装pyNvr</title>
    <link href="http://daoke123.github.io/2022/02/13/77/"/>
    <id>http://daoke123.github.io/2022/02/13/77/</id>
    <published>2022-02-13T13:46:00.000Z</published>
    <updated>2022-10-30T14:11:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><a class="link"   href="https://gitee.com/wfxzf/pyNvr" >pyNvr脚本<i class="fas fa-external-link-alt"></i></a></p><p>安装python3</p><p>如果使用百度网盘：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install bypy</span><br><span class="line">bypy info</span><br></pre></td></tr></table></figure><p>复制链接粘贴到浏览器打开，登录，填写授权码。<br>如果出错<br>试试删掉配置文件重新授权</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -Rf ~/.bypy</span><br><span class="line">rm -f ~/.bypy.*</span><br></pre></td></tr></table></figure><p>如果使用阿里云盘：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install aligo</span><br></pre></td></tr></table></figure><p>安装opencv：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install python3-opencv</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建保存视频的文件夹,例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /home/videos</span><br><span class="line">mkdir /home/videos/cam01</span><br></pre></td></tr></table></figure><p>一定要创建好路径，并且跟配置的路径一致，最后一层文件夹的名称为摄像头名称（camname）,参数pwd写到倒数第二层文件夹，以&#x2F;&#x2F;结尾即可。 编辑pyNvr.py,修改配置（选择netdisk（netdisk &#x3D; 1为百度，2为阿里），摄像头名称camname、串流地址url、本地存储路径pwd，单个视频时长blocktime,开启储存到百度网盘upyoby，上传完成后删除本地文件re_af_up）</p><p>运行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd pyNvr</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 pyNvr.py</span><br></pre></td></tr></table></figure><p>如果使用阿里网盘，第一次使用需要登录（百度已经登陆过）<br>如果二维码显示错乱，需要新建一个终端，手动找到&#x2F;tmp中的图片复制到手机可以直接访问的文件夹中，扫描，如：<br>cp &#x2F;tmp&#x2F;tmp56sdcc.png &#x2F;sdcard&#x2F;DCIM&#x2F;QRcode.png<br>打开文件管理，找到DCIM文件夹下的这张图，扫描即可。<br>测试没有问题后，ctrl + C终止程序。<br>后台运行程序:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup python3 pyNvr.py &amp;</span><br></pre></td></tr></table></figure><p>增加重启开机自动运行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nano /etc/rc.local</span><br></pre></td></tr></table></figure><p>把<br><code>nohup python3 /root/pyNvr/pyNvr.py &amp;</code><br>增加exit 0前面<br>程序极其简陋，稳定和安全毫无保障，仅仅用于不含任何隐私信息、图省钱省事还想多一层云备份的情况<br>仅建议用于linux不完整的安卓手机，云服务器、实体机、树莓派建议使用知名开源或商业软件，如bluebeery等。<br>附，国内常见IP摄像头串流地址:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">海康威视</span><br><span class="line">主码流：</span><br><span class="line">rtsp://user:password@ip:554/h264/ch1/main/av_stream</span><br><span class="line">子码流：</span><br><span class="line">rtsp://user:password@ip:554/mpeg4/ch1/sub/av_stream</span><br><span class="line"></span><br><span class="line">大华</span><br><span class="line">rtsp://username:password@ip:port/cam/realmonitor?channel=1&amp;subtype=0</span><br><span class="line"></span><br><span class="line">TP-Link/水星安防</span><br><span class="line">rtsp://user:password@ip:554/stream1</span><br><span class="line">rtsp://user:password@ip:554/stream2</span><br><span class="line">三星</span><br><span class="line">高码流rtsp地址：</span><br><span class="line">rtsp://user:password@ip:554/onvif/profile2/media.smp（720P）</span><br><span class="line">低码率rtsp地址</span><br><span class="line">rtsp://user:password@ip:554/onvif/profile3/media.smp</span><br><span class="line"></span><br><span class="line">LG</span><br><span class="line">高码流（主码流）RTSP地址：</span><br><span class="line">rtsp://user:password@ip:554/Master-0</span><br><span class="line">低码流（子码流）RTSP地址：</span><br><span class="line">rtsp://user:password@ip:554/Slave-0</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;https://gitee.com/wfxzf/pyNvr&quot; &gt;pyNvr脚本&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装python3&lt;/p&gt;
&lt;p&gt;如果使用百</summary>
      
    
    
    
    <category term="网络资源" scheme="http://daoke123.github.io/categories/%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 Dockerfile 定制镜像</title>
    <link href="http://daoke123.github.io/2022/01/21/76/"/>
    <id>http://daoke123.github.io/2022/01/21/76/</id>
    <published>2022-01-21T11:54:00.000Z</published>
    <updated>2022-10-30T14:11:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>示例 frps<br>创建一个文件夹 frp</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir frp &amp;&amp; cd frp</span><br></pre></td></tr></table></figure><p>编辑Dockerfile文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nano Dockerfile</span><br></pre></td></tr></table></figure><p>下面代码复制粘贴</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM alpine</span><br><span class="line">MAINTAINER Stille </span><br><span class="line"></span><br><span class="line">ENV FRP_VERSION 0.38.0</span><br><span class="line">WORKDIR /</span><br><span class="line"></span><br><span class="line">RUN set -xe &amp;&amp; \</span><br><span class="line">    apk add tzdata &amp;&amp; \</span><br><span class="line">    cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \</span><br><span class="line">    echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone &amp;&amp; \</span><br><span class="line">    apk del tzdata</span><br><span class="line"></span><br><span class="line">RUN set -x &amp;&amp; \</span><br><span class="line">    if [ &quot;$(uname -m)&quot; = &quot;x86_64&quot; ]; then export PLATFORM=amd64 ; else if [ &quot;$(uname -m)&quot; = &quot;aarch64&quot; ]; then export PLATFORM=arm64 ; fi fi &amp;&amp; \</span><br><span class="line">    wget --no-check-certificate https://github.com/fatedier/frp/releases/download/v$&#123;FRP_VERSION&#125;/frp_$&#123;FRP_VERSION&#125;_linux_$&#123;PLATFORM&#125;.tar.gz &amp;&amp; \ </span><br><span class="line">    tar xzf frp_$&#123;FRP_VERSION&#125;_linux_$&#123;PLATFORM&#125;.tar.gz &amp;&amp; \</span><br><span class="line">    cd frp_$&#123;FRP_VERSION&#125;_linux_$&#123;PLATFORM&#125; &amp;&amp; \</span><br><span class="line">    mkdir /frp &amp;&amp; \</span><br><span class="line">    mv frps frps.ini /frp &amp;&amp; \</span><br><span class="line">    cd .. &amp;&amp; \</span><br><span class="line">    rm -rf *.tar.gz frp_$&#123;FRP_VERSION&#125;_linux_$&#123;PLATFORM&#125;</span><br><span class="line"></span><br><span class="line">VOLUME /frp</span><br><span class="line"></span><br><span class="line">CMD /frp/frps -c /frp/frps.ini</span><br></pre></td></tr></table></figure><p>生成docker镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t mydaoke/frps:0.38 .</span><br></pre></td></tr></table></figure><p>mydaoke&#x2F;frps:0.38修改自己的名称<br>查看生成docker镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>试运行一下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --restart=always --network host -d -v /root/frp/frps.ini:/frp/frps.ini --name frps mydaoke/frps:0.38</span><br></pre></td></tr></table></figure><p>Ok</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;示例 frps&lt;br&gt;创建一个文件夹 frp&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mkdir frp &amp;amp;&amp;amp; c</summary>
      
    
    
    
    <category term="默认分类" scheme="http://daoke123.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>caddy安装</title>
    <link href="http://daoke123.github.io/2022/01/19/74/"/>
    <id>http://daoke123.github.io/2022/01/19/74/</id>
    <published>2022-01-19T12:45:00.000Z</published>
    <updated>2022-11-10T15:00:16.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install -y debian-keyring debian-archive-keyring apt-transport-https</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -1sLf &#x27;https://dl.cloudsmith.io/public/caddy/stable/gpg.key&#x27;  sudo apt-key add - </span><br><span class="line">curl -1sLf &#x27;https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt&#x27;  sudo tee -a /etc/apt/sources.list.d/caddy-stable.list</span><br><span class="line">    sudo apt update</span><br><span class="line">    sudo apt install caddy</span><br></pre></td></tr></table></figure><h4 id="证书位置"><a href="#证书位置" class="headerlink" title="证书位置"></a>证书位置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /var/lib/caddy/.local/share/caddy/certificates/acme-v02.api.letsencrypt.org-directory/</span><br></pre></td></tr></table></figure><h4 id="配置文件路径"><a href="#配置文件路径" class="headerlink" title="配置文件路径"></a>配置文件路径</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/caddy/Caddyfile</span><br></pre></td></tr></table></figure><p>修改配置后 重新加载配置</p><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">www.psvmc.cn &#123;</span><br><span class="line">    reverse_proxy localhost:9000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改配置后-重新加载配置"><a href="#修改配置后-重新加载配置" class="headerlink" title="修改配置后 重新加载配置"></a>修改配置后 重新加载配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl reload caddy</span><br></pre></td></tr></table></figure><p>Ubuntu<br><code>sudo systemctl restart caddy</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt install -y debian-keyring debian-archive-ke</summary>
      
    
    
    
    <category term="默认分类" scheme="http://daoke123.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux 文件/文件夹的创建、复制、移动、删除</title>
    <link href="http://daoke123.github.io/2022/01/18/73/"/>
    <id>http://daoke123.github.io/2022/01/18/73/</id>
    <published>2022-01-17T16:37:34.000Z</published>
    <updated>2022-11-10T15:21:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 命令行终端中，文件&#x2F;文件夹的创建、复制、移动、删除。</p><h6 id="文件夹创建命令"><a href="#文件夹创建命令" class="headerlink" title="文件夹创建命令"></a>文件夹创建命令</h6><ul><li>mkdir 1 #创建文件夹1到当前目录</li><li>mkdir -p 1&#x2F;2 #创建文件夹1，并在文件夹1中创建文件夹2</li></ul><h6 id="文件创建命令"><a href="#文件创建命令" class="headerlink" title="文件创建命令"></a>文件创建命令</h6><ul><li>touch 1.txt #创建文件1.txt到当前目录</li></ul><h6 id="rm-选项-文件或目录"><a href="#rm-选项-文件或目录" class="headerlink" title="rm 选项 文件或目录"></a>rm 选项 文件或目录</h6><p>选项说明</p><blockquote><p>-f 强制删除<br>-i 交互模式，在删除前询问用户是否操作<br>-r 递归删除，常用在目录的删除</p></blockquote><p>示例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -f 1.txt  #强制删除文件1.txt</span><br><span class="line">rm -rf 1/*  #递归强制删除文件夹1里面的所有文件和文件夹</span><br><span class="line">rm -rf 1 #递归强制删除文件夹1</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Linux 命令行终端中，文件&amp;#x2F;文件夹的创建、复制、移动、删除。&lt;/p&gt;
&lt;h6 id=&quot;文件夹创建命令&quot;&gt;&lt;a href=&quot;#文件夹创建命令&quot; class=&quot;headerlink&quot; title=&quot;文件夹创建命令&quot;&gt;&lt;/a&gt;文件夹创建命令&lt;/h6&gt;&lt;ul&gt;
&lt;li</summary>
      
    
    
    
    <category term="默认分类" scheme="http://daoke123.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>docker 制作自己的镜像</title>
    <link href="http://daoke123.github.io/2022/01/17/72/"/>
    <id>http://daoke123.github.io/2022/01/17/72/</id>
    <published>2022-01-16T17:16:50.000Z</published>
    <updated>2022-11-10T15:10:55.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="检查镜像"><a href="#检查镜像" class="headerlink" title="检查镜像"></a>检查镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker image</span><br></pre></td></tr></table></figure><h4 id="检查容器"><a href="#检查容器" class="headerlink" title="检查容器"></a>检查容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><h4 id="交互式运行debian镜像"><a href="#交互式运行debian镜像" class="headerlink" title="交互式运行debian镜像"></a>交互式运行debian镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -itd --name blog debian</span><br><span class="line">docker exec -it blog /bin/bash </span><br><span class="line">apt update</span><br><span class="line">apt install -y upgrade</span><br><span class="line">apt install -y vim curl wget bash htop</span><br><span class="line"></span><br><span class="line">cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure><h4 id="将容器变成镜像"><a href="#将容器变成镜像" class="headerlink" title="将容器变成镜像"></a>将容器变成镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker commit -m=&quot;debian环境&quot; -a=&quot;mydaoke&quot; blog mydaoke/debian:1.0</span><br><span class="line">-m：注释信息</span><br><span class="line">-a：作者名称</span><br><span class="line">blog：待提交的容器名称</span><br><span class="line">mydaoke/debian:1.0：提交后的镜像名:TAG</span><br></pre></td></tr></table></figure><h4 id="登录Docker-Hub"><a href="#登录Docker-Hub" class="headerlink" title="登录Docker Hub"></a>登录Docker Hub</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure><h4 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker push mydaoke/debian:1.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;检查镜像&quot;&gt;&lt;a href=&quot;#检查镜像&quot; class=&quot;headerlink&quot; title=&quot;检查镜像&quot;&gt;&lt;/a&gt;检查镜像&lt;/h4&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="默认分类" scheme="http://daoke123.github.io/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
</feed>
